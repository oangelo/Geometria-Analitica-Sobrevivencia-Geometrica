<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <title>Geometria Analítica: Sobrevivência Geométrica – Capítulo II</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <!-- Reveal.js Styles -->
    <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/theme/black.css" id="theme" />

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="https://unpkg.com/reveal.js/plugin/highlight/monokai.css" />

    <!-- Custom styles (if needed) -->
    <link rel="stylesheet" href="styles.css">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

        <!-- ========================= -->
        <!-- CAPÍTULO II - PRODUTO INTERNO NO R² -->
        <!-- ========================= -->

        <!-- Slide Horizontal 1: Título -->
        <section>
          <h1>Capítulo II – Produto Interno no R²</h1>
          <p>Em terras arruinadas, às vezes a melhor forma de sobreviver é entender como forças aparentemente opostas podem se alinhar ou coexistir.</p>
        </section>

        <!-- Slide Horizontal 3: Produto Escalar & Reflexão Rápida -->
        <section>
          <section>
            <h2>Definição do Produto Escalar</h2>
            <p>
            O <strong>Produto Interno</strong> (ou escalar) de dois vetores \(\vec{u}\) e \(\vec{v}\) em \(\mathbb{R}^2\) é dado por:
            </p>
            <p class="formula">\[
            \vec{u} \cdot \vec{v} = x_u\,x_v + y_u\,y_v
            \]</p>
            <p>Interpretação: quanto maior o valor, mais “alinhados” (menos atrito) os vetores estão.</p>
          </section>

          <section>
            <h3>Exercício</h3>
            <p>
            Um exercício simples num mundo difícil: sejam \(\vec{u} = (1,2)\) e \(\vec{v} = (3,-1)\). Calcule o produto escalar.
            </p>
          </section>
          <section>
            <h2>Propriedades do Produto Escalar</h2>
            <p>Há certas “leis” que nem mesmo o apocalipse consegue revogar:</p>
            <ul>
              <li><strong>Comutatividade:</strong> \(\vec{u} \cdot \vec{v} = \vec{v} \cdot \vec{u}\)</li>
              <li><strong>Distributividade:</strong> \(\vec{u} \cdot (\vec{v} + \vec{w}) = \vec{u} \cdot \vec{v} + \vec{u} \cdot \vec{w}\)</li>
              <li><strong>Associatividade com escalar:</strong> \((\alpha \vec{u}) \cdot \vec{v} = \alpha (\vec{u} \cdot \vec{v})\)</li>
              <li><strong>Auto produto:</strong> \(\vec{v} \cdot \vec{v} = \|\vec{v}\|^2\), a “potência” ou “força” do vetor medido ao quadrado.</li>
            </ul>
            <p>
            Em termos de ângulo, \(\vec{u} \cdot \vec{v} = \|\vec{u}\|\|\vec{v}\|\cos(\theta)\). Um valor positivo indica vetores “cooperando”, enquanto um negativo sugere competição intensa.
            </p>
          </section>

          <section>
            <h2>Reflexão Rápida</h2>
            <p>
            Nesses tempos hostis, aprender a medir “afinidade” ou “desalinhamento” entre vetores é como negociar com facções rivais: às vezes um simples acordo (produto escalar positivo) evita catástrofes nucleares.
            </p>
            <p><em>Teoria dos Jogos</em> (versão pós-apocalipse):</p>
            <ul>
              <li>Vetores cooperativos (ângulo menor que 90°) tendem a somar forças.</li>
              <li>Vetores concorrentes (ângulo maior que 90°) podem se anular ou destruir.</li>
            </ul>
          </section>

          <section>
            <h3>Pergunta Filosófica</h3>
            <p><em>Em que ponto a competição extrema entre grupos (vetores concorrentes) deixa de ser produtiva e passa a ser destrutiva?</em></p>
          </section>

          <section>
            <h2>Exemplos e Reflexões</h2>
            <p>
            Vamos analisar alguns cenários clássicos (como investigar ruínas diferentes em busca de suprimentos):
            </p>
            <ol>
              <li><strong>Vetores no eixo x e no eixo y:</strong><br>
                <em>Pergunta:</em> Se \(\vec{u} = (a,0)\) e \(\vec{v} = (0,b)\), qual o valor de \(\vec{u} \cdot \vec{v}\)?<br>
                <em>Reflexão:</em> O que esse resultado diz sobre o “alinhamento” desses vetores?
              </li>
              <li><strong>Vetores na mesma reta (colineares):</strong><br>
                <em>Pergunta:</em> Se \(\vec{u} = (2,0)\) e \(\vec{v} = (3,0)\), qual o valor de \(\vec{u} \cdot \vec{v}\)?<br>
                <em>Reflexão:</em> Como interpretar esse número em termos de cooperação ou competição?
              </li>
              <li><strong>Produto escalar de um vetor consigo mesmo:</strong><br>
                <em>Pergunta:</em> Se \(\vec{w} = (4,0)\), qual o valor de \(\vec{w} \cdot \vec{w}\)?<br>
                <em>Reflexão:</em> Consegue ver uma relação entre esse valor e o comprimento do vetor?
              </li>
            </ol>
            <p>
            Use esses exemplos para notar padrões: vetores perpendiculares <em>(nada a acrescentar)</em>, vetores alinhados <em>(reforçando o mesmo rumo)</em> e a conexão entre o produto escalar e o comprimento do vetor <em>(sua “força” intrínseca)</em>.
            </p>
          </section>
          <section>
            <h2>O Produto Escalar e a Física Pós-Apocalíptica</h2>
            <p>
            Em um mundo onde cada gota de energia é vital, compreender como o produto escalar funciona na Física é questão de sobrevivência.  
            Afinal, mover entulhos e abrir bunkers exige um planejamento preciso dos esforços.
            </p>
            <p>
            <strong>Trabalho (Work) em Física:</strong><br>
            \( W = \vec{F} \cdot \vec{d} = \|\vec{F}\|\|\vec{d}\|\cos(\theta) \)<br>
            Se a força estiver “alinhada” ao deslocamento, o trabalho é positivo (contribui para o progresso).  
            Se estiver na direção oposta, é como remar contra a maré radioativa.
            </p>
            <p>
            Essa mesma ideia de alinhamento (ou desalinhamento) se aplica em diversas grandezas físicas,  
            pois o produto escalar aparece em contextos como energia, potência e até em eletromagnetismo.  
            Em última análise, você está medindo quão “úteis” (ou não) forças e campos podem ser em relação a um determinado movimento ou direção.
            </p>
          </section>
          <section>
            <h3>Reflexão Estratégica</h3>
            <p>
            Se o seu objetivo é empurrar uma barricada até o abrigo, use a força no mesmo sentido do deslocamento.  
            Forças perpendiculares (ou contrárias) resultam em perda de esforços preciosos — e nenhum sobrevivente quer desperdiçar recursos em tempos tão austeros.
            </p>
            <p>
            <em>Dica de Sobrevivência:</em> ao planejar qualquer movimento, avalie o ângulo entre força e deslocamento.  
            Um simples cálculo de produto escalar pode ser a diferença entre encontrar suprimentos ou ficar à deriva no ermo.
            </p>
          </section>
        </section>

<!-- Slide de Projeção Vetorial Corrigido -->
<section>
  <h2>Simulador Vault-Tec: Projeção Vetorial</h2>
  
  <div class="canvas-container" style="position: relative; width: 450px; height: 450px; margin: 0 auto;">
    <div id="interaction-hint" style="position: absolute; top: -30px; left: 0; right: 0;
      color: #FFD700; padding: 5px; font-family: monospace; text-align: center;">
      Clique e arraste os círculos nas pontas dos vetores
    </div>
    
    <canvas id="projectionCanvas" width="450" height="450" 
      style="border: 1px solid #0f0; background-color: #111; cursor: default;"></canvas>
      
    <div id="projection-value" style="position: absolute; bottom: 10px; right: 10px; 
      background: rgba(0,0,0,0.7); color: #ADFF2F; padding: 5px 10px; font-family: monospace;">
      |proj| = 0
    </div>
  </div>
  
  <p style="margin-top: 15px;"><small>Use os círculos nas pontas dos vetores para manipulá-los e observe como a projeção muda.</small></p>
  
  <script>
    // Script para visualização da projeção vetorial com interatividade melhorada
    document.addEventListener('DOMContentLoaded', function() {
      // Inicializa quando o slide estiver visível
      Reveal.addEventListener('slidechanged', function(event) {
        const projectionCanvas = event.currentSlide.querySelector('#projectionCanvas');
        if (projectionCanvas) {
          initProjectionCanvas(projectionCanvas);
        }
      });
      
      // Também inicializa se o slide já estiver visível na carga inicial
      const currentSlide = Reveal.getCurrentSlide();
      if (currentSlide && currentSlide.querySelector('#projectionCanvas')) {
        initProjectionCanvas(currentSlide.querySelector('#projectionCanvas'));
      }
    });
    
    function initProjectionCanvas(canvas) {
      if (!canvas) return; // Sair se o canvas não for encontrado
      
      const ctx = canvas.getContext('2d');
      const valueDisplay = document.querySelector('#projection-value');
      const interactionHint = document.querySelector('#interaction-hint');
      
      // Configuração básica
      const width = canvas.width;
      const height = canvas.height;
      const centerX = width / 2;
      const centerY = height / 2;
      const scale = 30;
      
      // Vetores iniciais
      let vectorU = { x: 3, y: 1 };
      let vectorV = { x: 2, y: 0 };
      let projectionVector = { x: 0, y: 0 }; // Será calculado
      
      // Estado de interação
      let isDragging = false;
      let selectedVector = null;
      let hoverVector = null;
      
      // Configurações de estilo
      const handleRadius = 15; // Tamanho aumentado do círculo manipulável nas pontas dos vetores
      const colors = {
        u: '#FF6347',         // Vetor original (vermelho)
        v: '#4169E1',         // Vetor de direção (azul)
        proj: '#ADFF2F',      // Projeção (verde)
        projLine: '#FFD700',  // Linha de projeção (amarelo)
        handle: '#FFFFFF',    // Círculo manipulável
        handleHover: '#ADFF2F', // Círculo quando hovering
        grid: '#333333',      // Linhas de grid
        axes: '#00FF00'       // Eixos principais
      };
      
      function drawGrid() {
        ctx.strokeStyle = colors.grid;
        ctx.lineWidth = 0.5;
        
        // Eixos
        ctx.strokeStyle = colors.axes;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, centerY); ctx.lineTo(width, centerY);
        ctx.moveTo(centerX, 0); ctx.lineTo(centerX, height);
        ctx.stroke();
      }
      
      function drawVector(x, y, color, label, isHighlighted = false) {
        const endX = centerX + x * scale;
        const endY = centerY - y * scale;
        
        // Linha do vetor
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        
        // Seta na ponta
        const angle = Math.atan2(centerY - endY, endX - centerX);
        const arrowSize = 8;
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle - Math.PI / 6),
          endY - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle + Math.PI / 6),
          endY - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
        
        // Círculo manipulável na ponta do vetor
        ctx.beginPath();
        ctx.arc(endX, endY, handleRadius, 0, Math.PI * 2);
        ctx.fillStyle = isHighlighted ? colors.handleHover : 'rgba(255, 255, 255, 0.3)';
        ctx.fill();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Label
        ctx.fillStyle = color;
        ctx.font = '16px monospace';
        ctx.fillText(label, endX + 15, endY);
      }
      
      function drawProjectionLine() {
        // Desenhar linha tracejada da ponta de U perpendicular a V
        const endUX = centerX + vectorU.x * scale;
        const endUY = centerY - vectorU.y * scale;
        
        const endProjX = centerX + projectionVector.x * scale;
        const endProjY = centerY - projectionVector.y * scale;
        
        ctx.setLineDash([5, 3]);
        ctx.strokeStyle = colors.projLine;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(endUX, endUY);
        ctx.lineTo(endProjX, endProjY);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      function dotProduct(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y;
      }
      
      function magnitude(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
      }
      
      function calculateProjection() {
        // Calcula a projeção de U sobre V
        const magV = magnitude(vectorV);
        
        // Evitar divisão por zero
        if (magV < 0.0001) {
          projectionVector = { x: 0, y: 0 };
          return 0;
        }
        
        const dotProd = dotProduct(vectorU, vectorV);
        const scalar = dotProd / (magV * magV);
        
        projectionVector = {
          x: vectorV.x * scalar,
          y: vectorV.y * scalar
        };
        
        return magnitude(projectionVector);
      }
      
      function render() {
        ctx.clearRect(0, 0, width, height);
        drawGrid();
        
        // Calcular projeção
        const projMagnitude = calculateProjection();
        
        // Desenhar vetor V (direção de referência)
        drawVector(vectorV.x, vectorV.y, colors.v, 'v', hoverVector === 'V');
        
        // Desenhar vetor de projeção
        drawVector(projectionVector.x, projectionVector.y, colors.proj, 'proj');
        
        // Desenhar vetor U (vetor original)
        drawVector(vectorU.x, vectorU.y, colors.u, 'u', hoverVector === 'U');
        
        // Desenhar linha de projeção
        drawProjectionLine();
        
        // Atualizar valor da projeção
        if (valueDisplay) {
          valueDisplay.textContent = `|proj| = ${projMagnitude.toFixed(2)}`;
        }
      }
      
      function isNearVectorTip(mouseX, mouseY, vector) {
        const tipX = centerX + vector.x * scale;
        const tipY = centerY - vector.y * scale;
        
        const distance = Math.sqrt((mouseX - tipX) ** 2 + (mouseY - tipY) ** 2);
        return distance < handleRadius;
      }
      
      function getMousePos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        // Garantir que levamos em conta a posição exata, inclusive com o scaling que o navegador pode aplicar
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        return {
          x: (evt.clientX - rect.left) * scaleX,
          y: (evt.clientY - rect.top) * scaleY
        };
      }
      
      function updateCursor(isOverHandle) {
        canvas.style.cursor = isOverHandle ? 'pointer' : 'default';
      }
      
      function checkHover(mouseX, mouseY) {
        if (isNearVectorTip(mouseX, mouseY, vectorU)) {
          hoverVector = 'U';
          updateCursor(true);
          render(); // Re-render para mostrar highlight
          return true;
        } else if (isNearVectorTip(mouseX, mouseY, vectorV)) {
          hoverVector = 'V';
          updateCursor(true);
          render(); // Re-render para mostrar highlight
          return true;
        }
        
        if (hoverVector) {
          hoverVector = null;
          updateCursor(false);
          render(); // Re-render para remover highlight
        }
        return false;
      }
      
      // Eventos do mouse
      canvas.addEventListener('mousemove', function(event) {
        const mousePos = getMousePos(canvas, event);
        const mouseX = mousePos.x;
        const mouseY = mousePos.y;
        
        if (isDragging && selectedVector) {
          // Estamos arrastando um vetor
          const vecX = (mouseX - centerX) / scale;
          const vecY = -(mouseY - centerY) / scale;
          
          // Limitar magnitude para não sair da tela
          const mag = Math.sqrt(vecX*vecX + vecY*vecY);
          const maxMag = 4;
          const factor = mag > maxMag ? maxMag / mag : 1;
          
          if (selectedVector === 'U') {
            vectorU.x = vecX * factor;
            vectorU.y = vecY * factor;
          } else if (selectedVector === 'V') {
            vectorV.x = vecX * factor;
            vectorV.y = vecY * factor;
          }
          
          render();
        } else {
          // Verificar hover
          checkHover(mouseX, mouseY);
        }
      });
      
      canvas.addEventListener('mousedown', function(event) {
        const mousePos = getMousePos(canvas, event);
        const mouseX = mousePos.x;
        const mouseY = mousePos.y;
        
        if (isNearVectorTip(mouseX, mouseY, vectorU)) {
          isDragging = true;
          selectedVector = 'U';
          canvas.style.cursor = 'grabbing';
        } else if (isNearVectorTip(mouseX, mouseY, vectorV)) {
          isDragging = true;
          selectedVector = 'V';
          canvas.style.cursor = 'grabbing';
        }
        
        // Esconder a dica de interação após o primeiro clique
        if (isDragging && interactionHint) {
          interactionHint.style.opacity = '0.5';
        }
      });
      
      canvas.addEventListener('mouseup', function() {
        isDragging = false;
        selectedVector = null;
        canvas.style.cursor = hoverVector ? 'pointer' : 'default';
      });
      
      canvas.addEventListener('mouseleave', function() {
        isDragging = false;
        selectedVector = null;
        hoverVector = null;
        updateCursor(false);
      });
      
      // Apenas para debugging
      function logEventInfo(event, type) {
        const mousePos = getMousePos(canvas, event);
        console.log(`${type} - x: ${mousePos.x}, y: ${mousePos.y}`);
        console.log(`Canvas offset: ${canvas.offsetLeft}, ${canvas.offsetTop}`);
        console.log(`Reveal slide offset: ${Reveal.getCurrentSlide().offsetLeft}, ${Reveal.getCurrentSlide().offsetTop}`);
      }
      
      // Renderização inicial
      render();
    }
  </script>
</section>

        <!-- Slide Horizontal: Módulo (Comprimento) e Versores -->
        <section>
          <!-- Slide Vertical: Definição do Módulo -->
          <section>
            <h2>Módulo (Comprimento) de um Vetor</h2>
            <p>
            Para medir a intensidade de um vetor \(\vec{v} = (x, y)\) em \(\mathbb{R}^2\), utilizamos:
            </p>
            <p class="formula">\[
            |\vec{v}| = \sqrt{x^2 + y^2} = \sqrt{\vec{v} \cdot \vec{v}}
            \]</p>
            <p class="formula">\[ |\vec{v}|^2 = \vec{v} \cdot \vec{v} \]</p>

            <p>
            Essa fórmula deriva diretamente do Teorema de Pitágoras, considerando \(x\) e \(y\) como os catetos de um triângulo retângulo, cujo comprimento da hipotenusa é \(|\vec{v}|\).
            </p>
            <p>
            Em aplicações práticas, o módulo indica a “intensidade” ou “força” que esse vetor representa (por exemplo, a intensidade de uma força ou velocidade).
            </p>
          </section>

          <!-- Slide Vertical: Versor e Escrita de um Vetor -->
          <section>
            <h2>Versor (Vetor Unitário)</h2>
            <p>
            Qualquer vetor \(\vec{v}\) pode ser decomposto como seu módulo vezes um <em>vetor unitário</em>, também chamado de <em>versor</em>, que indica apenas a direção e o sentido:
            </p>
            <p class="formula">\[
            \vec{v} = |\vec{v}|\hat{v}, \quad\text{onde}\quad \hat{v} = \frac{\vec{v}}{|\vec{v}|}.
            \]</p>
            <p>
            Assim, <em>\(\hat{v}\)</em> possui módulo igual a 1 e aponta exatamente na direção de \(\vec{v}\). Esse conceito é útil para normalizar vetores em diversos cálculos, como projeções e direções de movimento.
            </p>
          </section>

          <!-- Slide Vertical: Base Canônica -->
          <section>
            <h2>Base Canônica em \(\mathbb{R}^2\)</h2>
            <p>
            Em \(\mathbb{R}^2\), a forma mais comum de representar um vetor é usando a base canônica:
            </p>
            <ul>
              <li>\(\hat{i} = (1,0)\)</li>
              <li>\(\hat{j} = (0,1)\)</li>
            </ul>
	    <p class="formula">\[
	    \vec{v} = x \hat{i} + y \hat{j}\]</p>
            <p>
            <p class="formula">\[
	    \vec{v} = (\vec{v} \cdot \hat{i}) \hat{i} + (\vec{v} \cdot \hat{J}) \hat{j}
            \]</p>
                        É outra maneira de ver a mesma informação: em vez de agrupar em um par ordenado \((x,y)\), distribuímos as componentes como “pesos” dos vetores unitários \(\hat{i}\) e \(\hat{j}\).
            </p>
          </section>

          <!-- Slide Vertical: Exercícios -->
          <section>
            <h2>Exercícios</h2>
            <ol>
              <li>Calcule o módulo de \(\vec{u} = (3, -2)\) usando \(\displaystyle |\vec{u}| = \sqrt{x^2 + y^2}\). Em seguida, escreva \(\vec{u}\) na forma \(|\vec{u}|\hat{u}\).</li>
              <li>Represente o mesmo vetor \(\vec{u} = (3, -2)\) em função da base canônica, \(\hat{i}\) e \(\hat{j}\).</li>
              <li>Escolha outro vetor \(\vec{v} = (x, y)\) e repita o processo:
                <ul>
                  <li>Encontre \(|\vec{v}|\).</li>
                  <li>Determine \(\hat{v}\).</li>
                  <li>Escreva \(\vec{v}\) em termos de \(\hat{i}\) e \(\hat{j}\).</li>
                </ul>
              </li>
            </ol>
          </section>
        </section>


        <section>
          <section>
            <h2>Distância entre Pontos: O Mapa da Sobrevivência</h2>
            <p>Em um mundo pós-apocalíptico, saber a distância entre dois pontos pode significar a diferença entre encontrar abrigo seguro ou se perder em território hostil. A matemática é o seu mapa confiável, revelando conexões espaciais com uma precisão implacável.</p>
          </section>

          <section>
            <h2>Definição Fundamental: A Fórmula da Jornada</h2>
            <p>Imagine dois abrigos, nas posições \(A(x_1, y_1)\) e \(B(x_2, y_2)\), separados por terrenos incertos. A fórmula a seguir dá a distância no seu GPS:</p>

            <div class="formula">
              \[d(A,B) = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\]
            </div>
            <blockquote>
              Esta fórmula é mais do que uma equação; é o roteiro para atravessar distâncias <strong>retas</strong>, desenhando pontes invisíveis entre pontos no vazio. Porém, lembre-se: em terrenos tortuosos, curvas e obstáculos desafiam essa simplicidade, exigindo outros cálculos para medir o verdadeiro trajeto.
            </blockquote>

          </section>

          <section>
            <h2>Vetores e Distância: O Trajeto do Explorador</h2>
            <p>Para entender o verdadeiro caminho, precisamos do <strong>vetor entre pontos</strong>, o traço deixado por quem já fez a travessia:</p>

            <div class="formula">
              \[\vec{AB} = \vec{B} - \vec{A} = (x_2 - x_1, y_2 - y_1)\]
            </div>

            <blockquote>
              <strong>Importante:</strong> Embora o vetor represente o caminho entre \(A\) e \(B\), ele sempre é traçado a partir da <em>origem</em>, o ponto zero da civilização.
            </blockquote>
          </section>
          <section>
            <h1>Explorando o terreno:</h1>
            <ul>
              <li>🗺️ O vetor \(\vec{AB}\) representa o deslocamento entre os abrigos \(A\) e \(B\)</li>
              <li>📍 Suas coordenadas mostram o quanto você precisa se mover em cada direção</li>
              <li>🚩 A distância é o comprimento deste vetor: \(|\vec{AB}|\)</li>
            </ul>
          </section>

          <section>
            <h2>Aplicações em Terrenos Inóspitos</h2>
            <p>A distância euclidiana é a bússola oculta por trás de muitas missões:</p>

            <ul>
              <li>🦠 Sobrevivência biológica: Mapeamento da propagação de vírus em áreas contaminadas</li>
              <li>🚀 Exploração espacial: Trajetórias entre estações e planetas</li>
              <li>🤖 Inteligência artificial: Algoritmos de busca em territórios virtuais</li>
            </ul>
          </section>

          <section>
            <h2>Missão Prática: Navegando no Plano Cartesiano</h2>

            <div class="formula">
              <h3>Desafio do Explorador</h3>
              <ol>
                <li>📌 Marque seus pontos de interesse:
                  <ul>
                    <li>\(A(2, 3)\) - O abrigo inicial</li>
                    <li>\(B(5, 1)\) - O posto avançado</li>
                  </ul>
                </li>
                <li>🗺️ Traçando a rota:
                  <ul>
                    <li>Desenhe o plano cartesiano com os pontos \(A\) e \(B\)</li>
                    <li>Calcule o vetor \(\vec{AB}\)</li>
                    <li>Projete o vetor a partir da <strong>origem</strong></li>
                  </ul>
                </li>
              </ol>
            </div>

            <blockquote>
              <strong>Cuidado:</strong> Mesmo que você esteja viajando de \(A\) para \(B\), o vetor \(\vec{AB}\) deve sempre começar na origem, onde sua jornada matemática começa.
            </blockquote>

            <div class="formula">
              Cálculo do vetor:
              \[\vec{AB} = (5-2, 1-3) = (3, -2)\]
            </div>

            <p>🔍 Análise: Esse vetor é o rastro da sua jornada, o registro do deslocamento necessário para atravessar o território desconhecido.</p>
          </section>

          <section>
            <h2>Missões Avançadas para Exploradores Matemáticos</h2>
            <ul>
              <li>📏 Calcular distâncias em sistemas de coordenadas alternativos (polar, esférico)</li>
              <li>🚧 Identificar onde a métrica euclidiana falha, como em terrenos não lineares</li>
              <li>🔭 Explorar distâncias em espaços de mais de duas dimensões: o universo é maior do que parece</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h1>Paralelismo e Ortogonalidade</h1>
            <h2>Navegando por Vetores em Terras Devastadas</h2>
          </section>

          <section>
            <h2>Fundamentos Conceituais</h2>
            <p>Imagine vetores como <strong>esquadrões de sobreviventes</strong> em um território hostil, cada um seguindo sua própria rota para encontrar recursos essenciais.</p>

            <div class="fragment">
              <h3>Vetores Paralelos</h3>
              <p>Dois vetores \(\vec{u}\) e \(\vec{v}\) são <span class="highlight">paralelos</span> quando um pode ser transformado no outro através de uma <em>multiplicação escalar</em>:</p>
              <p>\[\vec{u} = k \cdot \vec{v}\]</p>
              <p>💡 <em>Analogia de Sobrevivência</em>: Como trilhas seguras que seguem na mesma direção, seja em um deserto radioativo ou entre ruínas urbanas, independentemente da distância percorrida.</p>
            </div>
          </section>

          <section>
            <h3>Exemplo Prático de Paralelismo</h3>
            <p>Considere dois vetores em um mapa de zonas de perigo:</p>
            <ul>
              <li>\(\vec{u} = (2, 4)\)</li>
              <li>\(\vec{v} = (1, 2)\)</li>
            </ul>
            <p>Observe que \(\vec{u} = 2 \cdot \vec{v}\), portanto, são <strong>paralelos</strong> — como patrulhas que seguem rotas idênticas, mas em horários diferentes.</p>
            <div class="fragment">
              <p>🔍 <em>Teste de Paralelismo</em>: Divida as coordenadas de um vetor pelas do outro. Se o resultado for constante, parabéns! Você encontrou duas rotas alinhadas.</p>
            </div>
          </section>

          <section>
            <h2>Ortogonalidade: Independência em Campo de Batalha</h2>
            <p>Vetores ortogonais são como <strong>esquadrões táticos</strong> que operam de forma independente, cobrindo ângulos estratégicos sem interferir um no outro.</p>

            <div class="fragment">
              <h3>Definição Matemática</h3>
              <p>Dois vetores \(\vec{u}\) e \(\vec{v}\) são <span class="highlight">ortogonais</span> quando seu produto interno é zero:</p>
              <p>\[\vec{u} \cdot \vec{v} = 0\]</p>
              <p>💡 <em>Interpretação no Campo</em>: Eles formam um ângulo de 90 graus, garantindo que suas rotas não se cruzem — perfeito para evitar emboscadas.</p>
            </div>
          </section>

          <section>
            <h3>Exemplo de Ortogonalidade</h3>
            <p>Em uma base de operações:</p>
            <ul>
              <li>\(\vec{u} = (1, 0)\) - patrulha ao longo da fronteira leste-oeste</li>
              <li>\(\vec{v} = (0, 1)\) - patrulha ao longo da fronteira norte-sul</li>
            </ul>
            <p>Calculando o produto interno:</p>
            <p>\[\vec{u} \cdot \vec{v} = (1 \cdot 0) + (0 \cdot 1) = 0\]</p>
            <div class="fragment">
              <p>🎯 <em>Consequência Tática</em>: Esses esquadrões não interferem um no outro, maximizando a vigilância sem sobreposição de esforços.</p>
            </div>
          </section>

          <section>
            <h2>Missões de Sobrevivência</h2>
            <h3>Missão 1: Análise de Rota</h3>
            <p>Dados os vetores de movimentação:</p>
            <ul>
              <li>\(\vec{a} = (3, 4)\)</li>
              <li>\(\vec{b} = (4, -3)\)</li>
              <li>\(\vec{c} = (6, 8)\)</li>
            </ul>
            <p>Determine:</p>
            <ol>
              <li>Quais rotas seguem paralelas?</li>
              <li>Existe alguma configuração ortogonal, ideal para patrulhamento estratégico?</li>
            </ol>
          </section>

          <section>
            <h3>Missão 2: Sistemas de Navegação</h3>
            <p>Em um posto avançado, considere dois sensores:</p>
            <ul>
              <li>Sensor de movimento horizontal: \(\vec{m} = (1, 0)\)</li>
              <li>Sensor de movimento vertical: \(\vec{v} = (0, 1)\)</li>
            </ul>
            <p>Por que a ortogonalidade entre esses sensores é crucial para detectar ameaças com precisão?</p>
            <div class="fragment">
              <p>🌐 <em>Reflexão de Campo</em>: Sensores ortogonais garantem que nenhum movimento escape à vigilância, cobrindo ângulos mortos de forma eficiente.</p>
            </div>
          </section>

          <section>
            <h2>Reflexão Final</h2>
            <blockquote>
              <p>Em um mundo onde a sobrevivência depende da estratégia, a ortogonalidade não é apenas um conceito matemático, mas um princípio de eficiência e independência.</p>
            </blockquote>
            <p>Assim como esquadrões que operam de forma independente podem proteger uma base com eficácia, indivíduos com habilidades complementares criam comunidades resilientes em tempos de crise.</p>
          </section>
        </section>


        <section>
        <section>
          <h1>Área de Triângulos Vetoriais</h1>
          <h2>Decodificando Espaços, Revelando Estratégias</h2>
        </section>

          <section>
            <h2>Territórios Delimitados por Vetores</h2>
            <p>Imagine dois vetores, \(\vec{u}\) e \(\vec{v}\), como <strong>fronteiras invisíveis</strong> traçando os limites de um território em disputa.</p>

            <div class="fragment formula">
              <h3>Fórmula Fundamental</h3>
              <p>\[\text{Área} = \frac{1}{2} |\vec{u}| |\vec{v}| \sin(\theta)\]</p>
              <p>🔍 <em>Intuição Estratégica</em>: A área emerge da combinação da força (magnitude) e do ângulo (desalinhamento) entre os vetores.</p>
            </div>

            <div class="fragment">
              <p>📐 <strong>Elementos Essenciais</strong>:</p>
              <ul>
                <li>\(|\vec{u}|\) e \(|\vec{v}|\): Intensidade dos "movimentos"</li>
                <li>\(\sin(\theta)\): O grau de divergência entre as direções</li>
              </ul>
            </div>
          </section>

          <section>
            <h2>Relacionando Fórmulas Conhecidas</h2>
            <p>Lembre-se da fórmula clássica da área de um triângulo:</p>
            <p>\[ \text{Área} = \frac{\text{base} \times \text{altura}}{2} \]</p>
            <p>Se considerarmos \(|\vec{u}|\) como a base, então \(|\vec{v}| \sin(\theta)|\) é a altura — afinal, o módulo de um vetor vezes o seno do ângulo entre eles nos dá a altura do triângulo.</p>

            <div class="fragment">
              <p>📏 <strong>Conexão com Vetores:</strong></p>
              <ul>
                <li>\( \text{base} = |\vec{u}| \)</li>
                <li>\( \text{altura} = |\vec{v}| \sin(\theta) \)</li>
              </ul>
            </div>
          </section>

          <section>
            <h2>Determinantes e Áreas</h2>
            <p>A área do <strong>paralelogramo</strong> definido por dois vetores \(\vec{u}\) e \(\vec{v}\) pode ser calculada usando o determinante da matriz formada por esses vetores:</p>
            <p>\[ \text{Área do Paralelogramo} = | \det \begin{bmatrix} u_x & v_x \\ u_y & v_y \end{bmatrix} | \]</p>
            <p>Para encontrar a área do triângulo formado por esses vetores, basta dividir o resultado por 2:</p>
            <p>\[ \text{Área do Triângulo} = \frac{1}{2} | \det \begin{bmatrix} u_x & v_x \\ u_y & v_y \end{bmatrix} | \]</p>

            <div class="fragment">
              <blockquote>
                "O determinante não é só um número — é a medida do "espaço" criado por dois vetores."
              </blockquote>
            </div>
          </section>

          <section>
            <h2>Missão de Reconhecimento</h2>
            <p>Vetores em campo:</p>
            <ul>
              <li>\(\vec{u} = (3, 4)\) com módulo \(|\vec{u}| = 5\)</li>
              <li>\(\vec{v} = (1, 2)\) com módulo \(|\vec{v}| = \sqrt{5}\)</li>
            </ul>

            <div class="fragment">
              <h3>Plano de Ação</h3>
              <ol>
                <li>Calcular o determinante da matriz formada pelos vetores</li>
                <li>Aplicar a fórmula \( \text{Área} = \frac{1}{2} |\det| \)</li>
                <li>Comparar o resultado com a fórmula \( \frac{1}{2} |\vec{u}| |\vec{v}| \sin(\theta) \)</li>
              </ol>
            </div>
          </section>

          <section>
            <h2>Decodificação Matemática</h2>
            <p>Etapas do cálculo:</p>
            <ul>
              <li>Produto escalar para encontrar \(\cos(\theta)\)</li>
              <li>\(\sin(\theta) = \sqrt{1 - \cos^2(\theta)}\)</li>
              <li>Área = \(\frac{1}{2} |\vec{u}| |\vec{v}| \sin(\theta)\) <strong>ou</strong> \(\frac{1}{2} |\det|\)</li>
            </ul>

            <div class="fragment">
              <p>🎯 <strong>Resultado:</strong> O mesmo "território", apenas medido de formas diferentes.</p>
            </div>
          </section>

          <section>
            <h2>Desafio de Campo</h2>
            <p>Vetores em jogo:</p>
            <ul>
              <li>\(\vec{a} = (2, 2)\)</li>
              <li>\(\vec{b} = (3, -3)\)</li>
            </ul>
            <p>Tarefas:</p>
            <ol>
              <li>Calcular a área do triângulo usando o determinante</li>
              <li>Confirmar o resultado com a fórmula da área \( \frac{1}{2} |\vec{a}| |\vec{b}| \sin(\theta) \)</li>
              <li>Interpretar o significado geométrico do resultado (o que esse "território" representa?)</li>
            </ol>
          </section>

          <section>
            <h2>Reflexões Táticas</h2>
            <p>O que a área de um triângulo vetorial pode simbolizar?</p>
            <ul>
              <li>Zonas de influência entre forças</li>
              <li>Potencial de cobertura territorial</li>
              <li>Pontos críticos de interseção estratégica</li>
            </ul>

            <div class="fragment">
              <blockquote>
                "Na geometria, cada área é um espaço de possibilidades — e cada fórmula, uma nova perspectiva." 
              </blockquote>
            </div>
          </section>

          <section>
            <h2>Conclusão Estratégica</h2>
            <p>A área de um triângulo vetorial não é apenas um número. É a <strong>síntese de forças, direções e possibilidades</strong>. Seja através do determinante ou da fórmula clássica, o importante é compreender que tudo se conecta, como diferentes peças do mesmo quebra-cabeça.</p>
          </section>
        </section>


        <!-- Slide Horizontal 6: Fechamento -->
        <section>
          <h2>Fechamento</h2>
          <p>
          No fim do dia, nem todo confronto precisa explodir um bunker; às vezes, descobrir o alinhamento (produto escalar) entre facções pode ser o início de uma negociação viável.
          </p>
          <p>
          <em>Reflexão:</em> Em um mundo devastado, cooperação e respeito aos limites alheios (ortogonais) podem evitar <strong>jogos de soma zero</strong>. A soma das forças pode ser mais valiosa que um embate destrutivo.
          </p>
        </section>

      </div> <!-- .slides -->
    </div> <!-- .reveal -->

    <!-- Reveal.js -->
    <script src="https://unpkg.com/reveal.js/dist/reveal.js"></script>

    <!-- Reveal Plugins -->
    <script src="https://unpkg.com/reveal.js/plugin/notes/notes.js"></script>
    <script src="https://unpkg.com/reveal.js/plugin/highlight/highlight.js"></script>

    <!-- MathJax -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [["\\(","\\)"]],
          displayMath: [["\\[","\\]"]],
        },
        svg: { fontCache: 'global' }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <script>
      Reveal.initialize({
        hash: true,
        slideNumber: true,
        plugins: [ RevealNotes, RevealHighlight ]
      });
    </script>
  </body>
</html>

