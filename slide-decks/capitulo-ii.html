<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <title>Geometria Anal√≠tica: Sobreviv√™ncia Geom√©trica ‚Äì Cap√≠tulo II</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <!-- Reveal.js Styles -->
    <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/theme/black.css" id="theme" />

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="https://unpkg.com/reveal.js/plugin/highlight/monokai.css" />

    <!-- Custom styles (if needed) -->
    <link rel="stylesheet" href="styles.css">
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

        <!-- ========================= -->
        <!-- CAP√çTULO II - PRODUTO INTERNO NO R¬≤ -->
        <!-- ========================= -->

        <!-- Slide Horizontal 1: T√≠tulo -->
        <section>
          <h1>Cap√≠tulo II ‚Äì Produto Interno no R¬≤</h1>
          <p>Em terras arruinadas, √†s vezes a melhor forma de sobreviver √© entender como for√ßas aparentemente opostas podem se alinhar ou coexistir.</p>
        </section>

        <!-- Slide Horizontal 3: Produto Escalar & Reflex√£o R√°pida -->
        <section>
          <section>
            <h2>Defini√ß√£o do Produto Escalar</h2>
            <p>
            O <strong>Produto Interno</strong> (ou escalar) de dois vetores \(\vec{u}\) e \(\vec{v}\) em \(\mathbb{R}^2\) √© dado por:
            </p>
            <p class="formula">\[
            \vec{u} \cdot \vec{v} = x_u\,x_v + y_u\,y_v
            \]</p>
            <p>Interpreta√ß√£o: quanto maior o valor, mais ‚Äúalinhados‚Äù (menos atrito) os vetores est√£o.</p>
          </section>

          <section>
            <h3>Exerc√≠cio</h3>
            <p>
            Um exerc√≠cio simples num mundo dif√≠cil: sejam \(\vec{u} = (1,2)\) e \(\vec{v} = (3,-1)\). Calcule o produto escalar.
            </p>
          </section>
          <section>
            <h2>Propriedades do Produto Escalar</h2>
            <p>H√° certas ‚Äúleis‚Äù que nem mesmo o apocalipse consegue revogar:</p>
            <ul>
              <li><strong>Comutatividade:</strong> \(\vec{u} \cdot \vec{v} = \vec{v} \cdot \vec{u}\)</li>
              <li><strong>Distributividade:</strong> \(\vec{u} \cdot (\vec{v} + \vec{w}) = \vec{u} \cdot \vec{v} + \vec{u} \cdot \vec{w}\)</li>
              <li><strong>Associatividade com escalar:</strong> \((\alpha \vec{u}) \cdot \vec{v} = \alpha (\vec{u} \cdot \vec{v})\)</li>
              <li><strong>Auto produto:</strong> \(\vec{v} \cdot \vec{v} = \|\vec{v}\|^2\), a ‚Äúpot√™ncia‚Äù ou ‚Äúfor√ßa‚Äù do vetor medido ao quadrado.</li>
            </ul>
            <p>
            Em termos de √¢ngulo, \(\vec{u} \cdot \vec{v} = \|\vec{u}\|\|\vec{v}\|\cos(\theta)\). Um valor positivo indica vetores ‚Äúcooperando‚Äù, enquanto um negativo sugere competi√ß√£o intensa.
            </p>
          </section>

          <section>
            <h2>Reflex√£o R√°pida</h2>
            <p>
            Nesses tempos hostis, aprender a medir ‚Äúafinidade‚Äù ou ‚Äúdesalinhamento‚Äù entre vetores √© como negociar com fac√ß√µes rivais: √†s vezes um simples acordo (produto escalar positivo) evita cat√°strofes nucleares.
            </p>
            <p><em>Teoria dos Jogos</em> (vers√£o p√≥s-apocalipse):</p>
            <ul>
              <li>Vetores cooperativos (√¢ngulo menor que 90¬∞) tendem a somar for√ßas.</li>
              <li>Vetores concorrentes (√¢ngulo maior que 90¬∞) podem se anular ou destruir.</li>
            </ul>
          </section>

          <section>
            <h3>Pergunta Filos√≥fica</h3>
            <p><em>Em que ponto a competi√ß√£o extrema entre grupos (vetores concorrentes) deixa de ser produtiva e passa a ser destrutiva?</em></p>
          </section>

          <section>
            <h2>Exemplos e Reflex√µes</h2>
            <p>
            Vamos analisar alguns cen√°rios cl√°ssicos (como investigar ru√≠nas diferentes em busca de suprimentos):
            </p>
            <ol>
              <li><strong>Vetores no eixo x e no eixo y:</strong><br>
                <em>Pergunta:</em> Se \(\vec{u} = (a,0)\) e \(\vec{v} = (0,b)\), qual o valor de \(\vec{u} \cdot \vec{v}\)?<br>
                <em>Reflex√£o:</em> O que esse resultado diz sobre o ‚Äúalinhamento‚Äù desses vetores?
              </li>
              <li><strong>Vetores na mesma reta (colineares):</strong><br>
                <em>Pergunta:</em> Se \(\vec{u} = (2,0)\) e \(\vec{v} = (3,0)\), qual o valor de \(\vec{u} \cdot \vec{v}\)?<br>
                <em>Reflex√£o:</em> Como interpretar esse n√∫mero em termos de coopera√ß√£o ou competi√ß√£o?
              </li>
              <li><strong>Produto escalar de um vetor consigo mesmo:</strong><br>
                <em>Pergunta:</em> Se \(\vec{w} = (4,0)\), qual o valor de \(\vec{w} \cdot \vec{w}\)?<br>
                <em>Reflex√£o:</em> Consegue ver uma rela√ß√£o entre esse valor e o comprimento do vetor?
              </li>
            </ol>
            <p>
            Use esses exemplos para notar padr√µes: vetores perpendiculares <em>(nada a acrescentar)</em>, vetores alinhados <em>(refor√ßando o mesmo rumo)</em> e a conex√£o entre o produto escalar e o comprimento do vetor <em>(sua ‚Äúfor√ßa‚Äù intr√≠nseca)</em>.
            </p>
          </section>
          <section>
            <h2>O Produto Escalar e a F√≠sica P√≥s-Apocal√≠ptica</h2>
            <p>
            Em um mundo onde cada gota de energia √© vital, compreender como o produto escalar funciona na F√≠sica √© quest√£o de sobreviv√™ncia.  
            Afinal, mover entulhos e abrir bunkers exige um planejamento preciso dos esfor√ßos.
            </p>
            <p>
            <strong>Trabalho (Work) em F√≠sica:</strong><br>
            \( W = \vec{F} \cdot \vec{d} = \|\vec{F}\|\|\vec{d}\|\cos(\theta) \)<br>
            Se a for√ßa estiver ‚Äúalinhada‚Äù ao deslocamento, o trabalho √© positivo (contribui para o progresso).  
            Se estiver na dire√ß√£o oposta, √© como remar contra a mar√© radioativa.
            </p>
            <p>
            Essa mesma ideia de alinhamento (ou desalinhamento) se aplica em diversas grandezas f√≠sicas,  
            pois o produto escalar aparece em contextos como energia, pot√™ncia e at√© em eletromagnetismo.  
            Em √∫ltima an√°lise, voc√™ est√° medindo qu√£o ‚Äú√∫teis‚Äù (ou n√£o) for√ßas e campos podem ser em rela√ß√£o a um determinado movimento ou dire√ß√£o.
            </p>
          </section>
          <section>
            <h3>Reflex√£o Estrat√©gica</h3>
            <p>
            Se o seu objetivo √© empurrar uma barricada at√© o abrigo, use a for√ßa no mesmo sentido do deslocamento.  
            For√ßas perpendiculares (ou contr√°rias) resultam em perda de esfor√ßos preciosos ‚Äî e nenhum sobrevivente quer desperdi√ßar recursos em tempos t√£o austeros.
            </p>
            <p>
            <em>Dica de Sobreviv√™ncia:</em> ao planejar qualquer movimento, avalie o √¢ngulo entre for√ßa e deslocamento.  
            Um simples c√°lculo de produto escalar pode ser a diferen√ßa entre encontrar suprimentos ou ficar √† deriva no ermo.
            </p>
          </section>
        </section>

<!-- Slide de Proje√ß√£o Vetorial Corrigido -->
<section>
  <h2>Simulador Vault-Tec: Proje√ß√£o Vetorial</h2>
  
  <div class="canvas-container" style="position: relative; width: 450px; height: 450px; margin: 0 auto;">
    <div id="interaction-hint" style="position: absolute; top: -30px; left: 0; right: 0;
      color: #FFD700; padding: 5px; font-family: monospace; text-align: center;">
      Clique e arraste os c√≠rculos nas pontas dos vetores
    </div>
    
    <canvas id="projectionCanvas" width="450" height="450" 
      style="border: 1px solid #0f0; background-color: #111; cursor: default;"></canvas>
      
    <div id="projection-value" style="position: absolute; bottom: 10px; right: 10px; 
      background: rgba(0,0,0,0.7); color: #ADFF2F; padding: 5px 10px; font-family: monospace;">
      |proj| = 0
    </div>
  </div>
  
  <p style="margin-top: 15px;"><small>Use os c√≠rculos nas pontas dos vetores para manipul√°-los e observe como a proje√ß√£o muda.</small></p>
  
  <script>
    // Script para visualiza√ß√£o da proje√ß√£o vetorial com interatividade melhorada
    document.addEventListener('DOMContentLoaded', function() {
      // Inicializa quando o slide estiver vis√≠vel
      Reveal.addEventListener('slidechanged', function(event) {
        const projectionCanvas = event.currentSlide.querySelector('#projectionCanvas');
        if (projectionCanvas) {
          initProjectionCanvas(projectionCanvas);
        }
      });
      
      // Tamb√©m inicializa se o slide j√° estiver vis√≠vel na carga inicial
      const currentSlide = Reveal.getCurrentSlide();
      if (currentSlide && currentSlide.querySelector('#projectionCanvas')) {
        initProjectionCanvas(currentSlide.querySelector('#projectionCanvas'));
      }
    });
    
    function initProjectionCanvas(canvas) {
      if (!canvas) return; // Sair se o canvas n√£o for encontrado
      
      const ctx = canvas.getContext('2d');
      const valueDisplay = document.querySelector('#projection-value');
      const interactionHint = document.querySelector('#interaction-hint');
      
      // Configura√ß√£o b√°sica
      const width = canvas.width;
      const height = canvas.height;
      const centerX = width / 2;
      const centerY = height / 2;
      const scale = 30;
      
      // Vetores iniciais
      let vectorU = { x: 3, y: 1 };
      let vectorV = { x: 2, y: 0 };
      let projectionVector = { x: 0, y: 0 }; // Ser√° calculado
      
      // Estado de intera√ß√£o
      let isDragging = false;
      let selectedVector = null;
      let hoverVector = null;
      
      // Configura√ß√µes de estilo
      const handleRadius = 15; // Tamanho aumentado do c√≠rculo manipul√°vel nas pontas dos vetores
      const colors = {
        u: '#FF6347',         // Vetor original (vermelho)
        v: '#4169E1',         // Vetor de dire√ß√£o (azul)
        proj: '#ADFF2F',      // Proje√ß√£o (verde)
        projLine: '#FFD700',  // Linha de proje√ß√£o (amarelo)
        handle: '#FFFFFF',    // C√≠rculo manipul√°vel
        handleHover: '#ADFF2F', // C√≠rculo quando hovering
        grid: '#333333',      // Linhas de grid
        axes: '#00FF00'       // Eixos principais
      };
      
      function drawGrid() {
        ctx.strokeStyle = colors.grid;
        ctx.lineWidth = 0.5;
        
        // Eixos
        ctx.strokeStyle = colors.axes;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, centerY); ctx.lineTo(width, centerY);
        ctx.moveTo(centerX, 0); ctx.lineTo(centerX, height);
        ctx.stroke();
      }
      
      function drawVector(x, y, color, label, isHighlighted = false) {
        const endX = centerX + x * scale;
        const endY = centerY - y * scale;
        
        // Linha do vetor
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        
        // Seta na ponta
        const angle = Math.atan2(centerY - endY, endX - centerX);
        const arrowSize = 8;
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle - Math.PI / 6),
          endY - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          endX - arrowSize * Math.cos(angle + Math.PI / 6),
          endY - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
        
        // C√≠rculo manipul√°vel na ponta do vetor
        ctx.beginPath();
        ctx.arc(endX, endY, handleRadius, 0, Math.PI * 2);
        ctx.fillStyle = isHighlighted ? colors.handleHover : 'rgba(255, 255, 255, 0.3)';
        ctx.fill();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Label
        ctx.fillStyle = color;
        ctx.font = '16px monospace';
        ctx.fillText(label, endX + 15, endY);
      }
      
      function drawProjectionLine() {
        // Desenhar linha tracejada da ponta de U perpendicular a V
        const endUX = centerX + vectorU.x * scale;
        const endUY = centerY - vectorU.y * scale;
        
        const endProjX = centerX + projectionVector.x * scale;
        const endProjY = centerY - projectionVector.y * scale;
        
        ctx.setLineDash([5, 3]);
        ctx.strokeStyle = colors.projLine;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(endUX, endUY);
        ctx.lineTo(endProjX, endProjY);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      function dotProduct(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y;
      }
      
      function magnitude(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y);
      }
      
      function calculateProjection() {
        // Calcula a proje√ß√£o de U sobre V
        const magV = magnitude(vectorV);
        
        // Evitar divis√£o por zero
        if (magV < 0.0001) {
          projectionVector = { x: 0, y: 0 };
          return 0;
        }
        
        const dotProd = dotProduct(vectorU, vectorV);
        const scalar = dotProd / (magV * magV);
        
        projectionVector = {
          x: vectorV.x * scalar,
          y: vectorV.y * scalar
        };
        
        return magnitude(projectionVector);
      }
      
      function render() {
        ctx.clearRect(0, 0, width, height);
        drawGrid();
        
        // Calcular proje√ß√£o
        const projMagnitude = calculateProjection();
        
        // Desenhar vetor V (dire√ß√£o de refer√™ncia)
        drawVector(vectorV.x, vectorV.y, colors.v, 'v', hoverVector === 'V');
        
        // Desenhar vetor de proje√ß√£o
        drawVector(projectionVector.x, projectionVector.y, colors.proj, 'proj');
        
        // Desenhar vetor U (vetor original)
        drawVector(vectorU.x, vectorU.y, colors.u, 'u', hoverVector === 'U');
        
        // Desenhar linha de proje√ß√£o
        drawProjectionLine();
        
        // Atualizar valor da proje√ß√£o
        if (valueDisplay) {
          valueDisplay.textContent = `|proj| = ${projMagnitude.toFixed(2)}`;
        }
      }
      
      function isNearVectorTip(mouseX, mouseY, vector) {
        const tipX = centerX + vector.x * scale;
        const tipY = centerY - vector.y * scale;
        
        const distance = Math.sqrt((mouseX - tipX) ** 2 + (mouseY - tipY) ** 2);
        return distance < handleRadius;
      }
      
      function getMousePos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        // Garantir que levamos em conta a posi√ß√£o exata, inclusive com o scaling que o navegador pode aplicar
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        
        return {
          x: (evt.clientX - rect.left) * scaleX,
          y: (evt.clientY - rect.top) * scaleY
        };
      }
      
      function updateCursor(isOverHandle) {
        canvas.style.cursor = isOverHandle ? 'pointer' : 'default';
      }
      
      function checkHover(mouseX, mouseY) {
        if (isNearVectorTip(mouseX, mouseY, vectorU)) {
          hoverVector = 'U';
          updateCursor(true);
          render(); // Re-render para mostrar highlight
          return true;
        } else if (isNearVectorTip(mouseX, mouseY, vectorV)) {
          hoverVector = 'V';
          updateCursor(true);
          render(); // Re-render para mostrar highlight
          return true;
        }
        
        if (hoverVector) {
          hoverVector = null;
          updateCursor(false);
          render(); // Re-render para remover highlight
        }
        return false;
      }
      
      // Eventos do mouse
      canvas.addEventListener('mousemove', function(event) {
        const mousePos = getMousePos(canvas, event);
        const mouseX = mousePos.x;
        const mouseY = mousePos.y;
        
        if (isDragging && selectedVector) {
          // Estamos arrastando um vetor
          const vecX = (mouseX - centerX) / scale;
          const vecY = -(mouseY - centerY) / scale;
          
          // Limitar magnitude para n√£o sair da tela
          const mag = Math.sqrt(vecX*vecX + vecY*vecY);
          const maxMag = 4;
          const factor = mag > maxMag ? maxMag / mag : 1;
          
          if (selectedVector === 'U') {
            vectorU.x = vecX * factor;
            vectorU.y = vecY * factor;
          } else if (selectedVector === 'V') {
            vectorV.x = vecX * factor;
            vectorV.y = vecY * factor;
          }
          
          render();
        } else {
          // Verificar hover
          checkHover(mouseX, mouseY);
        }
      });
      
      canvas.addEventListener('mousedown', function(event) {
        const mousePos = getMousePos(canvas, event);
        const mouseX = mousePos.x;
        const mouseY = mousePos.y;
        
        if (isNearVectorTip(mouseX, mouseY, vectorU)) {
          isDragging = true;
          selectedVector = 'U';
          canvas.style.cursor = 'grabbing';
        } else if (isNearVectorTip(mouseX, mouseY, vectorV)) {
          isDragging = true;
          selectedVector = 'V';
          canvas.style.cursor = 'grabbing';
        }
        
        // Esconder a dica de intera√ß√£o ap√≥s o primeiro clique
        if (isDragging && interactionHint) {
          interactionHint.style.opacity = '0.5';
        }
      });
      
      canvas.addEventListener('mouseup', function() {
        isDragging = false;
        selectedVector = null;
        canvas.style.cursor = hoverVector ? 'pointer' : 'default';
      });
      
      canvas.addEventListener('mouseleave', function() {
        isDragging = false;
        selectedVector = null;
        hoverVector = null;
        updateCursor(false);
      });
      
      // Apenas para debugging
      function logEventInfo(event, type) {
        const mousePos = getMousePos(canvas, event);
        console.log(`${type} - x: ${mousePos.x}, y: ${mousePos.y}`);
        console.log(`Canvas offset: ${canvas.offsetLeft}, ${canvas.offsetTop}`);
        console.log(`Reveal slide offset: ${Reveal.getCurrentSlide().offsetLeft}, ${Reveal.getCurrentSlide().offsetTop}`);
      }
      
      // Renderiza√ß√£o inicial
      render();
    }
  </script>
</section>

        <!-- Slide Horizontal: M√≥dulo (Comprimento) e Versores -->
        <section>
          <!-- Slide Vertical: Defini√ß√£o do M√≥dulo -->
          <section>
            <h2>M√≥dulo (Comprimento) de um Vetor</h2>
            <p>
            Para medir a intensidade de um vetor \(\vec{v} = (x, y)\) em \(\mathbb{R}^2\), utilizamos:
            </p>
            <p class="formula">\[
            |\vec{v}| = \sqrt{x^2 + y^2} = \sqrt{\vec{v} \cdot \vec{v}}
            \]</p>
            <p class="formula">\[ |\vec{v}|^2 = \vec{v} \cdot \vec{v} \]</p>

            <p>
            Essa f√≥rmula deriva diretamente do Teorema de Pit√°goras, considerando \(x\) e \(y\) como os catetos de um tri√¢ngulo ret√¢ngulo, cujo comprimento da hipotenusa √© \(|\vec{v}|\).
            </p>
            <p>
            Em aplica√ß√µes pr√°ticas, o m√≥dulo indica a ‚Äúintensidade‚Äù ou ‚Äúfor√ßa‚Äù que esse vetor representa (por exemplo, a intensidade de uma for√ßa ou velocidade).
            </p>
          </section>

          <!-- Slide Vertical: Versor e Escrita de um Vetor -->
          <section>
            <h2>Versor (Vetor Unit√°rio)</h2>
            <p>
            Qualquer vetor \(\vec{v}\) pode ser decomposto como seu m√≥dulo vezes um <em>vetor unit√°rio</em>, tamb√©m chamado de <em>versor</em>, que indica apenas a dire√ß√£o e o sentido:
            </p>
            <p class="formula">\[
            \vec{v} = |\vec{v}|\hat{v}, \quad\text{onde}\quad \hat{v} = \frac{\vec{v}}{|\vec{v}|}.
            \]</p>
            <p>
            Assim, <em>\(\hat{v}\)</em> possui m√≥dulo igual a 1 e aponta exatamente na dire√ß√£o de \(\vec{v}\). Esse conceito √© √∫til para normalizar vetores em diversos c√°lculos, como proje√ß√µes e dire√ß√µes de movimento.
            </p>
          </section>

          <!-- Slide Vertical: Base Can√¥nica -->
          <section>
            <h2>Base Can√¥nica em \(\mathbb{R}^2\)</h2>
            <p>
            Em \(\mathbb{R}^2\), a forma mais comum de representar um vetor √© usando a base can√¥nica:
            </p>
            <ul>
              <li>\(\hat{i} = (1,0)\)</li>
              <li>\(\hat{j} = (0,1)\)</li>
            </ul>
	    <p class="formula">\[
	    \vec{v} = x \hat{i} + y \hat{j}\]</p>
            <p>
            <p class="formula">\[
	    \vec{v} = (\vec{v} \cdot \hat{i}) \hat{i} + (\vec{v} \cdot \hat{J}) \hat{j}
            \]</p>
                        √â outra maneira de ver a mesma informa√ß√£o: em vez de agrupar em um par ordenado \((x,y)\), distribu√≠mos as componentes como ‚Äúpesos‚Äù dos vetores unit√°rios \(\hat{i}\) e \(\hat{j}\).
            </p>
          </section>

          <!-- Slide Vertical: Exerc√≠cios -->
          <section>
            <h2>Exerc√≠cios</h2>
            <ol>
              <li>Calcule o m√≥dulo de \(\vec{u} = (3, -2)\) usando \(\displaystyle |\vec{u}| = \sqrt{x^2 + y^2}\). Em seguida, escreva \(\vec{u}\) na forma \(|\vec{u}|\hat{u}\).</li>
              <li>Represente o mesmo vetor \(\vec{u} = (3, -2)\) em fun√ß√£o da base can√¥nica, \(\hat{i}\) e \(\hat{j}\).</li>
              <li>Escolha outro vetor \(\vec{v} = (x, y)\) e repita o processo:
                <ul>
                  <li>Encontre \(|\vec{v}|\).</li>
                  <li>Determine \(\hat{v}\).</li>
                  <li>Escreva \(\vec{v}\) em termos de \(\hat{i}\) e \(\hat{j}\).</li>
                </ul>
              </li>
            </ol>
          </section>
        </section>


        <section>
          <section>
            <h2>Dist√¢ncia entre Pontos: O Mapa da Sobreviv√™ncia</h2>
            <p>Em um mundo p√≥s-apocal√≠ptico, saber a dist√¢ncia entre dois pontos pode significar a diferen√ßa entre encontrar abrigo seguro ou se perder em territ√≥rio hostil. A matem√°tica √© o seu mapa confi√°vel, revelando conex√µes espaciais com uma precis√£o implac√°vel.</p>
          </section>

          <section>
            <h2>Defini√ß√£o Fundamental: A F√≥rmula da Jornada</h2>
            <p>Imagine dois abrigos, nas posi√ß√µes \(A(x_1, y_1)\) e \(B(x_2, y_2)\), separados por terrenos incertos. A f√≥rmula a seguir d√° a dist√¢ncia no seu GPS:</p>

            <div class="formula">
              \[d(A,B) = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\]
            </div>
            <blockquote>
              Esta f√≥rmula √© mais do que uma equa√ß√£o; √© o roteiro para atravessar dist√¢ncias <strong>retas</strong>, desenhando pontes invis√≠veis entre pontos no vazio. Por√©m, lembre-se: em terrenos tortuosos, curvas e obst√°culos desafiam essa simplicidade, exigindo outros c√°lculos para medir o verdadeiro trajeto.
            </blockquote>

          </section>

          <section>
            <h2>Vetores e Dist√¢ncia: O Trajeto do Explorador</h2>
            <p>Para entender o verdadeiro caminho, precisamos do <strong>vetor entre pontos</strong>, o tra√ßo deixado por quem j√° fez a travessia:</p>

            <div class="formula">
              \[\vec{AB} = \vec{B} - \vec{A} = (x_2 - x_1, y_2 - y_1)\]
            </div>

            <blockquote>
              <strong>Importante:</strong> Embora o vetor represente o caminho entre \(A\) e \(B\), ele sempre √© tra√ßado a partir da <em>origem</em>, o ponto zero da civiliza√ß√£o.
            </blockquote>
          </section>
          <section>
            <h1>Explorando o terreno:</h1>
            <ul>
              <li>üó∫Ô∏è O vetor \(\vec{AB}\) representa o deslocamento entre os abrigos \(A\) e \(B\)</li>
              <li>üìç Suas coordenadas mostram o quanto voc√™ precisa se mover em cada dire√ß√£o</li>
              <li>üö© A dist√¢ncia √© o comprimento deste vetor: \(|\vec{AB}|\)</li>
            </ul>
          </section>

          <section>
            <h2>Aplica√ß√µes em Terrenos In√≥spitos</h2>
            <p>A dist√¢ncia euclidiana √© a b√∫ssola oculta por tr√°s de muitas miss√µes:</p>

            <ul>
              <li>ü¶† Sobreviv√™ncia biol√≥gica: Mapeamento da propaga√ß√£o de v√≠rus em √°reas contaminadas</li>
              <li>üöÄ Explora√ß√£o espacial: Trajet√≥rias entre esta√ß√µes e planetas</li>
              <li>ü§ñ Intelig√™ncia artificial: Algoritmos de busca em territ√≥rios virtuais</li>
            </ul>
          </section>

          <section>
            <h2>Miss√£o Pr√°tica: Navegando no Plano Cartesiano</h2>

            <div class="formula">
              <h3>Desafio do Explorador</h3>
              <ol>
                <li>üìå Marque seus pontos de interesse:
                  <ul>
                    <li>\(A(2, 3)\) - O abrigo inicial</li>
                    <li>\(B(5, 1)\) - O posto avan√ßado</li>
                  </ul>
                </li>
                <li>üó∫Ô∏è Tra√ßando a rota:
                  <ul>
                    <li>Desenhe o plano cartesiano com os pontos \(A\) e \(B\)</li>
                    <li>Calcule o vetor \(\vec{AB}\)</li>
                    <li>Projete o vetor a partir da <strong>origem</strong></li>
                  </ul>
                </li>
              </ol>
            </div>

            <blockquote>
              <strong>Cuidado:</strong> Mesmo que voc√™ esteja viajando de \(A\) para \(B\), o vetor \(\vec{AB}\) deve sempre come√ßar na origem, onde sua jornada matem√°tica come√ßa.
            </blockquote>

            <div class="formula">
              C√°lculo do vetor:
              \[\vec{AB} = (5-2, 1-3) = (3, -2)\]
            </div>

            <p>üîç An√°lise: Esse vetor √© o rastro da sua jornada, o registro do deslocamento necess√°rio para atravessar o territ√≥rio desconhecido.</p>
          </section>

          <section>
            <h2>Miss√µes Avan√ßadas para Exploradores Matem√°ticos</h2>
            <ul>
              <li>üìè Calcular dist√¢ncias em sistemas de coordenadas alternativos (polar, esf√©rico)</li>
              <li>üöß Identificar onde a m√©trica euclidiana falha, como em terrenos n√£o lineares</li>
              <li>üî≠ Explorar dist√¢ncias em espa√ßos de mais de duas dimens√µes: o universo √© maior do que parece</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h1>Paralelismo e Ortogonalidade</h1>
            <h2>Navegando por Vetores em Terras Devastadas</h2>
          </section>

          <section>
            <h2>Fundamentos Conceituais</h2>
            <p>Imagine vetores como <strong>esquadr√µes de sobreviventes</strong> em um territ√≥rio hostil, cada um seguindo sua pr√≥pria rota para encontrar recursos essenciais.</p>

            <div class="fragment">
              <h3>Vetores Paralelos</h3>
              <p>Dois vetores \(\vec{u}\) e \(\vec{v}\) s√£o <span class="highlight">paralelos</span> quando um pode ser transformado no outro atrav√©s de uma <em>multiplica√ß√£o escalar</em>:</p>
              <p>\[\vec{u} = k \cdot \vec{v}\]</p>
              <p>üí° <em>Analogia de Sobreviv√™ncia</em>: Como trilhas seguras que seguem na mesma dire√ß√£o, seja em um deserto radioativo ou entre ru√≠nas urbanas, independentemente da dist√¢ncia percorrida.</p>
            </div>
          </section>

          <section>
            <h3>Exemplo Pr√°tico de Paralelismo</h3>
            <p>Considere dois vetores em um mapa de zonas de perigo:</p>
            <ul>
              <li>\(\vec{u} = (2, 4)\)</li>
              <li>\(\vec{v} = (1, 2)\)</li>
            </ul>
            <p>Observe que \(\vec{u} = 2 \cdot \vec{v}\), portanto, s√£o <strong>paralelos</strong> ‚Äî como patrulhas que seguem rotas id√™nticas, mas em hor√°rios diferentes.</p>
            <div class="fragment">
              <p>üîç <em>Teste de Paralelismo</em>: Divida as coordenadas de um vetor pelas do outro. Se o resultado for constante, parab√©ns! Voc√™ encontrou duas rotas alinhadas.</p>
            </div>
          </section>

          <section>
            <h2>Ortogonalidade: Independ√™ncia em Campo de Batalha</h2>
            <p>Vetores ortogonais s√£o como <strong>esquadr√µes t√°ticos</strong> que operam de forma independente, cobrindo √¢ngulos estrat√©gicos sem interferir um no outro.</p>

            <div class="fragment">
              <h3>Defini√ß√£o Matem√°tica</h3>
              <p>Dois vetores \(\vec{u}\) e \(\vec{v}\) s√£o <span class="highlight">ortogonais</span> quando seu produto interno √© zero:</p>
              <p>\[\vec{u} \cdot \vec{v} = 0\]</p>
              <p>üí° <em>Interpreta√ß√£o no Campo</em>: Eles formam um √¢ngulo de 90 graus, garantindo que suas rotas n√£o se cruzem ‚Äî perfeito para evitar emboscadas.</p>
            </div>
          </section>

          <section>
            <h3>Exemplo de Ortogonalidade</h3>
            <p>Em uma base de opera√ß√µes:</p>
            <ul>
              <li>\(\vec{u} = (1, 0)\) - patrulha ao longo da fronteira leste-oeste</li>
              <li>\(\vec{v} = (0, 1)\) - patrulha ao longo da fronteira norte-sul</li>
            </ul>
            <p>Calculando o produto interno:</p>
            <p>\[\vec{u} \cdot \vec{v} = (1 \cdot 0) + (0 \cdot 1) = 0\]</p>
            <div class="fragment">
              <p>üéØ <em>Consequ√™ncia T√°tica</em>: Esses esquadr√µes n√£o interferem um no outro, maximizando a vigil√¢ncia sem sobreposi√ß√£o de esfor√ßos.</p>
            </div>
          </section>

          <section>
            <h2>Miss√µes de Sobreviv√™ncia</h2>
            <h3>Miss√£o 1: An√°lise de Rota</h3>
            <p>Dados os vetores de movimenta√ß√£o:</p>
            <ul>
              <li>\(\vec{a} = (3, 4)\)</li>
              <li>\(\vec{b} = (4, -3)\)</li>
              <li>\(\vec{c} = (6, 8)\)</li>
            </ul>
            <p>Determine:</p>
            <ol>
              <li>Quais rotas seguem paralelas?</li>
              <li>Existe alguma configura√ß√£o ortogonal, ideal para patrulhamento estrat√©gico?</li>
            </ol>
          </section>

          <section>
            <h3>Miss√£o 2: Sistemas de Navega√ß√£o</h3>
            <p>Em um posto avan√ßado, considere dois sensores:</p>
            <ul>
              <li>Sensor de movimento horizontal: \(\vec{m} = (1, 0)\)</li>
              <li>Sensor de movimento vertical: \(\vec{v} = (0, 1)\)</li>
            </ul>
            <p>Por que a ortogonalidade entre esses sensores √© crucial para detectar amea√ßas com precis√£o?</p>
            <div class="fragment">
              <p>üåê <em>Reflex√£o de Campo</em>: Sensores ortogonais garantem que nenhum movimento escape √† vigil√¢ncia, cobrindo √¢ngulos mortos de forma eficiente.</p>
            </div>
          </section>

          <section>
            <h2>Reflex√£o Final</h2>
            <blockquote>
              <p>Em um mundo onde a sobreviv√™ncia depende da estrat√©gia, a ortogonalidade n√£o √© apenas um conceito matem√°tico, mas um princ√≠pio de efici√™ncia e independ√™ncia.</p>
            </blockquote>
            <p>Assim como esquadr√µes que operam de forma independente podem proteger uma base com efic√°cia, indiv√≠duos com habilidades complementares criam comunidades resilientes em tempos de crise.</p>
          </section>
        </section>


        <section>
        <section>
          <h1>√Årea de Tri√¢ngulos Vetoriais</h1>
          <h2>Decodificando Espa√ßos, Revelando Estrat√©gias</h2>
        </section>

          <section>
            <h2>Territ√≥rios Delimitados por Vetores</h2>
            <p>Imagine dois vetores, \(\vec{u}\) e \(\vec{v}\), como <strong>fronteiras invis√≠veis</strong> tra√ßando os limites de um territ√≥rio em disputa.</p>

            <div class="fragment formula">
              <h3>F√≥rmula Fundamental</h3>
              <p>\[\text{√Årea} = \frac{1}{2} |\vec{u}| |\vec{v}| \sin(\theta)\]</p>
              <p>üîç <em>Intui√ß√£o Estrat√©gica</em>: A √°rea emerge da combina√ß√£o da for√ßa (magnitude) e do √¢ngulo (desalinhamento) entre os vetores.</p>
            </div>

            <div class="fragment">
              <p>üìê <strong>Elementos Essenciais</strong>:</p>
              <ul>
                <li>\(|\vec{u}|\) e \(|\vec{v}|\): Intensidade dos "movimentos"</li>
                <li>\(\sin(\theta)\): O grau de diverg√™ncia entre as dire√ß√µes</li>
              </ul>
            </div>
          </section>

          <section>
            <h2>Relacionando F√≥rmulas Conhecidas</h2>
            <p>Lembre-se da f√≥rmula cl√°ssica da √°rea de um tri√¢ngulo:</p>
            <p>\[ \text{√Årea} = \frac{\text{base} \times \text{altura}}{2} \]</p>
            <p>Se considerarmos \(|\vec{u}|\) como a base, ent√£o \(|\vec{v}| \sin(\theta)|\) √© a altura ‚Äî afinal, o m√≥dulo de um vetor vezes o seno do √¢ngulo entre eles nos d√° a altura do tri√¢ngulo.</p>

            <div class="fragment">
              <p>üìè <strong>Conex√£o com Vetores:</strong></p>
              <ul>
                <li>\( \text{base} = |\vec{u}| \)</li>
                <li>\( \text{altura} = |\vec{v}| \sin(\theta) \)</li>
              </ul>
            </div>
          </section>

          <section>
            <h2>Determinantes e √Åreas</h2>
            <p>A √°rea do <strong>paralelogramo</strong> definido por dois vetores \(\vec{u}\) e \(\vec{v}\) pode ser calculada usando o determinante da matriz formada por esses vetores:</p>
            <p>\[ \text{√Årea do Paralelogramo} = | \det \begin{bmatrix} u_x & v_x \\ u_y & v_y \end{bmatrix} | \]</p>
            <p>Para encontrar a √°rea do tri√¢ngulo formado por esses vetores, basta dividir o resultado por 2:</p>
            <p>\[ \text{√Årea do Tri√¢ngulo} = \frac{1}{2} | \det \begin{bmatrix} u_x & v_x \\ u_y & v_y \end{bmatrix} | \]</p>

            <div class="fragment">
              <blockquote>
                "O determinante n√£o √© s√≥ um n√∫mero ‚Äî √© a medida do "espa√ßo" criado por dois vetores."
              </blockquote>
            </div>
          </section>

          <section>
            <h2>Miss√£o de Reconhecimento</h2>
            <p>Vetores em campo:</p>
            <ul>
              <li>\(\vec{u} = (3, 4)\) com m√≥dulo \(|\vec{u}| = 5\)</li>
              <li>\(\vec{v} = (1, 2)\) com m√≥dulo \(|\vec{v}| = \sqrt{5}\)</li>
            </ul>

            <div class="fragment">
              <h3>Plano de A√ß√£o</h3>
              <ol>
                <li>Calcular o determinante da matriz formada pelos vetores</li>
                <li>Aplicar a f√≥rmula \( \text{√Årea} = \frac{1}{2} |\det| \)</li>
                <li>Comparar o resultado com a f√≥rmula \( \frac{1}{2} |\vec{u}| |\vec{v}| \sin(\theta) \)</li>
              </ol>
            </div>
          </section>

          <section>
            <h2>Decodifica√ß√£o Matem√°tica</h2>
            <p>Etapas do c√°lculo:</p>
            <ul>
              <li>Produto escalar para encontrar \(\cos(\theta)\)</li>
              <li>\(\sin(\theta) = \sqrt{1 - \cos^2(\theta)}\)</li>
              <li>√Årea = \(\frac{1}{2} |\vec{u}| |\vec{v}| \sin(\theta)\) <strong>ou</strong> \(\frac{1}{2} |\det|\)</li>
            </ul>

            <div class="fragment">
              <p>üéØ <strong>Resultado:</strong> O mesmo "territ√≥rio", apenas medido de formas diferentes.</p>
            </div>
          </section>

          <section>
            <h2>Desafio de Campo</h2>
            <p>Vetores em jogo:</p>
            <ul>
              <li>\(\vec{a} = (2, 2)\)</li>
              <li>\(\vec{b} = (3, -3)\)</li>
            </ul>
            <p>Tarefas:</p>
            <ol>
              <li>Calcular a √°rea do tri√¢ngulo usando o determinante</li>
              <li>Confirmar o resultado com a f√≥rmula da √°rea \( \frac{1}{2} |\vec{a}| |\vec{b}| \sin(\theta) \)</li>
              <li>Interpretar o significado geom√©trico do resultado (o que esse "territ√≥rio" representa?)</li>
            </ol>
          </section>

          <section>
            <h2>Reflex√µes T√°ticas</h2>
            <p>O que a √°rea de um tri√¢ngulo vetorial pode simbolizar?</p>
            <ul>
              <li>Zonas de influ√™ncia entre for√ßas</li>
              <li>Potencial de cobertura territorial</li>
              <li>Pontos cr√≠ticos de interse√ß√£o estrat√©gica</li>
            </ul>

            <div class="fragment">
              <blockquote>
                "Na geometria, cada √°rea √© um espa√ßo de possibilidades ‚Äî e cada f√≥rmula, uma nova perspectiva." 
              </blockquote>
            </div>
          </section>

          <section>
            <h2>Conclus√£o Estrat√©gica</h2>
            <p>A √°rea de um tri√¢ngulo vetorial n√£o √© apenas um n√∫mero. √â a <strong>s√≠ntese de for√ßas, dire√ß√µes e possibilidades</strong>. Seja atrav√©s do determinante ou da f√≥rmula cl√°ssica, o importante √© compreender que tudo se conecta, como diferentes pe√ßas do mesmo quebra-cabe√ßa.</p>
          </section>
        </section>


        <!-- Slide Horizontal 6: Fechamento -->
        <section>
          <h2>Fechamento</h2>
          <p>
          No fim do dia, nem todo confronto precisa explodir um bunker; √†s vezes, descobrir o alinhamento (produto escalar) entre fac√ß√µes pode ser o in√≠cio de uma negocia√ß√£o vi√°vel.
          </p>
          <p>
          <em>Reflex√£o:</em> Em um mundo devastado, coopera√ß√£o e respeito aos limites alheios (ortogonais) podem evitar <strong>jogos de soma zero</strong>. A soma das for√ßas pode ser mais valiosa que um embate destrutivo.
          </p>
        </section>

      </div> <!-- .slides -->
    </div> <!-- .reveal -->

    <!-- Reveal.js -->
    <script src="https://unpkg.com/reveal.js/dist/reveal.js"></script>

    <!-- Reveal Plugins -->
    <script src="https://unpkg.com/reveal.js/plugin/notes/notes.js"></script>
    <script src="https://unpkg.com/reveal.js/plugin/highlight/highlight.js"></script>

    <!-- MathJax -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [["\\(","\\)"]],
          displayMath: [["\\[","\\]"]],
        },
        svg: { fontCache: 'global' }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <script>
      Reveal.initialize({
        hash: true,
        slideNumber: true,
        plugins: [ RevealNotes, RevealHighlight ]
      });
    </script>
  </body>
</html>

