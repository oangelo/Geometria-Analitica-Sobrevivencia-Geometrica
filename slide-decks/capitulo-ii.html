<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <title>Geometria Anal√≠tica: Sobreviv√™ncia Geom√©trica ‚Äì Cap√≠tulo II</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <!-- Reveal.js Styles -->
    <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/reveal.css" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/reveal.js/dist/theme/black.css"
      id="theme"
    />

    <!-- For syntax highlighting -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/reveal.js/plugin/highlight/monokai.css"
    />

    <!-- Custom styles (if needed) -->
    <link rel="stylesheet" href="styles.css" />
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <!-- ========================= -->
        <!-- CAP√çTULO II - PRODUTO INTERNO NO R¬≤ -->
        <!-- ========================= -->

        <!-- Slide Horizontal 1: T√≠tulo -->
        <section>
          <h1>Cap√≠tulo II ‚Äì Produto Interno no R¬≤</h1>
          <p>
            Em terras arruinadas, √†s vezes a melhor forma de sobreviver √©
            entender como for√ßas aparentemente opostas podem se alinhar ou
            coexistir.
          </p>
        </section>

        <!-- Slide Horizontal 3: Produto Escalar & Reflex√£o R√°pida -->
        <section>
          <section>
            <h2>Defini√ß√£o do Produto Escalar</h2>
            <p>
              O <strong>Produto Interno</strong> (ou escalar) de dois vetores
              \(\vec{u}\) e \(\vec{v}\) em \(\mathbb{R}^2\) √© dado por:
            </p>
            <p class="formula">
              \[ \vec{u} \cdot \vec{v} = x_u\,x_v + y_u\,y_v \]
            </p>
            <p>
              Interpreta√ß√£o: quanto maior o valor, mais ‚Äúalinhados‚Äù (menos
              atrito) os vetores est√£o.
            </p>
          </section>

          <section>
            <h3>Exerc√≠cio</h3>
            <p>
              Um exerc√≠cio simples num mundo dif√≠cil: sejam \(\vec{u} = (1,2)\)
              e \(\vec{v} = (3,-1)\). Calcule o produto escalar.
            </p>
          </section>
          <section>
            <h2>Propriedades do Produto Escalar</h2>
            <p>H√° certas ‚Äúleis‚Äù que nem mesmo o apocalipse consegue revogar:</p>
            <ul>
              <li>
                <strong>Comutatividade:</strong> \(\vec{u} \cdot \vec{v} =
                \vec{v} \cdot \vec{u}\)
              </li>
              <li>
                <strong>Distributividade:</strong> \(\vec{u} \cdot (\vec{v} +
                \vec{w}) = \vec{u} \cdot \vec{v} + \vec{u} \cdot \vec{w}\)
              </li>
              <li>
                <strong>Associatividade com escalar:</strong> \((\alpha \vec{u})
                \cdot \vec{v} = \alpha (\vec{u} \cdot \vec{v})\)
              </li>
              <li>
                <strong>Auto produto:</strong> \(\vec{v} \cdot \vec{v} =
                \|\vec{v}\|^2\), a ‚Äúpot√™ncia‚Äù ou ‚Äúfor√ßa‚Äù do vetor medido ao
                quadrado.
              </li>
            </ul>
            <p>
              Em termos de √¢ngulo, \(\vec{u} \cdot \vec{v} =
              \|\vec{u}\|\|\vec{v}\|\cos(\theta)\). Um valor positivo indica
              vetores ‚Äúcooperando‚Äù, enquanto um negativo sugere competi√ß√£o
              intensa.
            </p>
          </section>

          <section>
            <h2>Reflex√£o R√°pida</h2>
            <p>
              Nesses tempos hostis, aprender a medir ‚Äúafinidade‚Äù ou
              ‚Äúdesalinhamento‚Äù entre vetores √© como negociar com fac√ß√µes rivais:
              √†s vezes um simples acordo (produto escalar positivo) evita
              cat√°strofes nucleares.
            </p>
            <p><em>Teoria dos Jogos</em> (vers√£o p√≥s-apocalipse):</p>
            <ul>
              <li>
                Vetores cooperativos (√¢ngulo menor que 90¬∞) tendem a somar
                for√ßas.
              </li>
              <li>
                Vetores concorrentes (√¢ngulo maior que 90¬∞) podem se anular ou
                destruir.
              </li>
            </ul>
          </section>

          <section>
            <h3>Pergunta Filos√≥fica</h3>
            <p>
              <em
                >Em que ponto a competi√ß√£o extrema entre grupos (vetores
                concorrentes) deixa de ser produtiva e passa a ser
                destrutiva?</em
              >
            </p>
          </section>

          <section>
            <h2>Exemplos e Reflex√µes</h2>
            <p>
              Vamos analisar alguns cen√°rios cl√°ssicos (como investigar ru√≠nas
              diferentes em busca de suprimentos):
            </p>
            <ol>
              <li>
                <strong>Vetores no eixo x e no eixo y:</strong><br />
                <em>Pergunta:</em> Se \(\vec{u} = (a,0)\) e \(\vec{v} = (0,b)\),
                qual o valor de \(\vec{u} \cdot \vec{v}\)?<br />
                <em>Reflex√£o:</em> O que esse resultado diz sobre o
                ‚Äúalinhamento‚Äù desses vetores?
              </li>
              <li>
                <strong>Vetores na mesma reta (colineares):</strong><br />
                <em>Pergunta:</em> Se \(\vec{u} = (2,0)\) e \(\vec{v} = (3,0)\),
                qual o valor de \(\vec{u} \cdot \vec{v}\)?<br />
                <em>Reflex√£o:</em> Como interpretar esse n√∫mero em termos de
                coopera√ß√£o ou competi√ß√£o?
              </li>
              <li>
                <strong>Produto escalar de um vetor consigo mesmo:</strong
                ><br />
                <em>Pergunta:</em> Se \(\vec{w} = (4,0)\), qual o valor de
                \(\vec{w} \cdot \vec{w}\)?<br />
                <em>Reflex√£o:</em> Consegue ver uma rela√ß√£o entre esse valor e o
                comprimento do vetor?
              </li>
            </ol>
            <p>
              Use esses exemplos para notar padr√µes: vetores perpendiculares
              <em>(nada a acrescentar)</em>, vetores alinhados
              <em>(refor√ßando o mesmo rumo)</em> e a conex√£o entre o produto
              escalar e o comprimento do vetor
              <em>(sua ‚Äúfor√ßa‚Äù intr√≠nseca)</em>.
            </p>
          </section>
          <section>
            <h2>O Produto Escalar e a F√≠sica P√≥s-Apocal√≠ptica</h2>
            <p>
              Em um mundo onde cada gota de energia √© vital, compreender como o
              produto escalar funciona na F√≠sica √© quest√£o de sobreviv√™ncia.
              Afinal, mover entulhos e abrir bunkers exige um planejamento
              preciso dos esfor√ßos.
            </p>
            <p>
              <strong>Trabalho (Work) em F√≠sica:</strong><br />
              \( W = \vec{F} \cdot \vec{d} = \|\vec{F}\|\|\vec{d}\|\cos(\theta)
              \)<br />
              Se a for√ßa estiver ‚Äúalinhada‚Äù ao deslocamento, o trabalho √©
              positivo (contribui para o progresso). Se estiver na dire√ß√£o
              oposta, √© como remar contra a mar√© radioativa.
            </p>
            <p>
              Essa mesma ideia de alinhamento (ou desalinhamento) se aplica em
              diversas grandezas f√≠sicas, pois o produto escalar aparece em
              contextos como energia, pot√™ncia e at√© em eletromagnetismo. Em
              √∫ltima an√°lise, voc√™ est√° medindo qu√£o ‚Äú√∫teis‚Äù (ou n√£o) for√ßas e
              campos podem ser em rela√ß√£o a um determinado movimento ou dire√ß√£o.
            </p>
          </section>
          <section>
            <h3>Reflex√£o Estrat√©gica</h3>
            <p>
              Se o seu objetivo √© empurrar uma barricada at√© o abrigo, use a
              for√ßa no mesmo sentido do deslocamento. For√ßas perpendiculares (ou
              contr√°rias) resultam em perda de esfor√ßos preciosos ‚Äî e nenhum
              sobrevivente quer desperdi√ßar recursos em tempos t√£o austeros.
            </p>
            <p>
              <em>Dica de Sobreviv√™ncia:</em> ao planejar qualquer movimento,
              avalie o √¢ngulo entre for√ßa e deslocamento. Um simples c√°lculo de
              produto escalar pode ser a diferen√ßa entre encontrar suprimentos
              ou ficar √† deriva no ermo.
            </p>
          </section>
        </section>

        <!-- Slide Horizontal: Proje√ß√£o Vetorial -->
        <section>
          <!-- Slide Vertical 1: Conceito de Proje√ß√£o -->
          <section>
            <h2>Proje√ß√£o Vetorial: Otimizando Recursos</h2>

            <div style="display: flex; align-items: center">
              <div style="flex: 2">
                <p>
                  Nem sempre podemos seguir a dire√ß√£o ideal em uma wasteland
                  hostil. Precisamos saber quanto de nosso esfor√ßo ser√° efetivo
                  em uma dire√ß√£o espec√≠fica.
                </p>
                <p class="formula">
                  \[ \text{proj}_{\vec{v}}\vec{u} = \frac{\vec{u} \cdot
                  \vec{v}}{|\vec{v}|^2}\vec{v} = (\vec{u} \cdot \hat{v})\hat{v}
                  \]
                </p>
                <p>
                  <em>Interpreta√ß√£o:</em> A proje√ß√£o extrai a componente de
                  \(\vec{u}\) que atua na dire√ß√£o de \(\vec{v}\).
                </p>
              </div>

              <div
                style="
                  flex: 1;
                  border-left: 2px solid #ffd700;
                  padding-left: 15px;
                "
              >
                <div
                  style="
                    background-color: rgba(50, 50, 50, 0.7);
                    padding: 10px;
                    border-radius: 5px;
                  "
                >
                  <p style="color: #ffd700; margin: 0">‚ò¢Ô∏è MNEM√îNICO</p>
                  <p
                    style="
                      margin: 5px 0 0 0;
                      font-style: italic;
                      font-size: 0.9em;
                    "
                  >
                    "Proje√ß√£o √© como um holofote: mostra apenas a sombra do
                    vetor na dire√ß√£o que interessa."
                  </p>
                </div>
              </div>
            </div>

            <div class="pip-boy-note">
              <p>
                Em termos t√°ticos: A proje√ß√£o nos diz quanto de nossa for√ßa
                (vetor \(\vec{u}\)) √© efetivamente aplicada na dire√ß√£o que
                desejamos seguir (vetor \(\vec{v}\)).
              </p>
            </div>
          </section>

          <!-- Slide Vertical 2: Visualiza√ß√£o Interativa -->
          <section data-state="projection-slide">
            <h2>Simulador Vault-Tec: Proje√ß√£o Vetorial</h2>

            <div
              class="canvas-container"
              style="
                position: relative;
                width: 450px;
                height: 450px;
                margin: 0 auto;
              "
            >
              <canvas
                id="projectionCanvas"
                width="450"
                height="450"
                style="
                  border: 1px solid #0f0;
                  background-color: #111;
                  cursor: default;
                "
              ></canvas>

              <div
                id="projection-value"
                style="
                  position: absolute;
                  bottom: 10px;
                  right: 10px;
                  background: rgba(0, 0, 0, 0.7);
                  color: #adff2f;
                  padding: 5px 10px;
                  font-family: monospace;
                "
              >
                |proj| = 0
              </div>
            </div>

            <p>
              <small
                >Use os c√≠rculos nas pontas dos vetores para manipul√°-los e
                observe como a proje√ß√£o muda.</small
              >
            </p>

            <script>
              // Configurar o nosso inicializador para rodar quando o Reveal.js estiver pronto
              document.addEventListener("DOMContentLoaded", function () {
                // Inicializar quando o slide espec√≠fico for mostrado
                Reveal.addEventListener("projection-slide", function () {
                  console.log(
                    "Slide de proje√ß√£o ativo, inicializando canvas...",
                  );
                  setTimeout(function () {
                    initProjectionCanvas(
                      document.getElementById("projectionCanvas"),
                    );
                  }, 200); // Pequeno atraso para garantir que o slide esteja completamente renderizado
                });

                // Se o slide j√° estiver ativo na carga inicial, inicializar
                if (
                  Reveal.getCurrentSlide().classList.contains(
                    "projection-slide",
                  ) ||
                  Reveal.getCurrentSlide().dataset.state === "projection-slide"
                ) {
                  console.log(
                    "Slide de proje√ß√£o j√° est√° ativo na carga inicial",
                  );
                  setTimeout(function () {
                    initProjectionCanvas(
                      document.getElementById("projectionCanvas"),
                    );
                  }, 200);
                }
              });

              function initProjectionCanvas(canvas) {
                if (!canvas) {
                  console.error("Canvas n√£o encontrado!");
                  return;
                }

                console.log("Inicializando canvas de proje√ß√£o...");

                // Desativar os atalhos de teclado do Reveal.js durante intera√ß√µes com o canvas
                function disableRevealKeyboard() {
                  Reveal.configure({ keyboard: false });
                }

                function enableRevealKeyboard() {
                  Reveal.configure({ keyboard: true });
                }

                const ctx = canvas.getContext("2d");
                const valueDisplay =
                  document.getElementById("projection-value");
                const interactionHint =
                  document.getElementById("interaction-hint");

                // Configura√ß√£o b√°sica
                const width = canvas.width;
                const height = canvas.height;
                const centerX = width / 2;
                const centerY = height / 2;
                const scale = 30;

                // Vetores iniciais
                let vectorU = { x: 3, y: 1 };
                let vectorV = { x: 2, y: 0 };
                let projectionVector = { x: 0, y: 0 }; // Ser√° calculado

                // Estado de intera√ß√£o
                let isDragging = false;
                let selectedVector = null;
                let hoverVector = null;

                // Configura√ß√µes de estilo
                const handleRadius = 15; // Tamanho aumentado do c√≠rculo manipul√°vel nas pontas dos vetores
                const colors = {
                  u: "#FF6347", // Vetor original (vermelho)
                  v: "#4169E1", // Vetor de dire√ß√£o (azul)
                  proj: "#ADFF2F", // Proje√ß√£o (verde)
                  projLine: "#FFD700", // Linha de proje√ß√£o (amarelo)
                  handle: "#FFFFFF", // C√≠rculo manipul√°vel
                  handleHover: "#ADFF2F", // C√≠rculo quando hovering
                  grid: "#333333", // Linhas de grid
                  axes: "#00FF00", // Eixos principais
                };

                function drawGrid() {
                  ctx.strokeStyle = colors.grid;
                  ctx.lineWidth = 0.5;

                  // Eixos
                  ctx.strokeStyle = colors.axes;
                  ctx.lineWidth = 1;
                  ctx.beginPath();
                  ctx.moveTo(0, centerY);
                  ctx.lineTo(width, centerY);
                  ctx.moveTo(centerX, 0);
                  ctx.lineTo(centerX, height);
                  ctx.stroke();
                }

                function drawVector(
                  x,
                  y,
                  color,
                  label,
                  isHighlighted = false,
                  drawHandle = true,
                ) {
                  const endX = centerX + x * scale;
                  const endY = centerY - y * scale;

                  // Linha do vetor
                  ctx.strokeStyle = color;
                  ctx.lineWidth = 2;
                  ctx.beginPath();
                  ctx.moveTo(centerX, centerY);
                  ctx.lineTo(endX, endY);
                  ctx.stroke();

                  // Desenhar a seta corretamente
                  if (Math.abs(x) > 0.1 || Math.abs(y) > 0.1) {
                    // N√£o desenhar seta para vetores muito pequenos
                    // Calcular o √¢ngulo do vetor
                    const angle = Math.atan2(-y, x); // Nota: y √© negativo por causa da invers√£o do eixo y no canvas

                    // Tamanho da seta
                    const arrowSize = 10;

                    // Desenhar a seta na ponta do vetor
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                      endX - arrowSize * Math.cos(angle - Math.PI / 6),
                      endY - arrowSize * Math.sin(angle - Math.PI / 6),
                    );
                    ctx.lineTo(
                      endX - arrowSize * Math.cos(angle + Math.PI / 6),
                      endY - arrowSize * Math.sin(angle + Math.PI / 6),
                    );
                    ctx.closePath();
                    ctx.fillStyle = color;
                    ctx.fill();
                  }

                  // C√≠rculo manipul√°vel na ponta do vetor (apenas se drawHandle for true)
                  if (drawHandle) {
                    ctx.beginPath();
                    ctx.arc(endX, endY, handleRadius, 0, Math.PI * 2);
                    ctx.fillStyle = isHighlighted
                      ? colors.handleHover
                      : "rgba(255, 255, 255, 0.3)";
                    ctx.fill();
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                  }

                  // Label
                  ctx.fillStyle = color;
                  ctx.font = "16px monospace";
                  ctx.fillText(label, endX + 15, endY);
                }

                function drawProjectionLine() {
                  // Desenhar linha tracejada da ponta de U perpendicular a V
                  const endUX = centerX + vectorU.x * scale;
                  const endUY = centerY - vectorU.y * scale;

                  const endProjX = centerX + projectionVector.x * scale;
                  const endProjY = centerY - projectionVector.y * scale;

                  ctx.setLineDash([5, 3]);
                  ctx.strokeStyle = colors.projLine;
                  ctx.lineWidth = 1;
                  ctx.beginPath();
                  ctx.moveTo(endUX, endUY);
                  ctx.lineTo(endProjX, endProjY);
                  ctx.stroke();
                  ctx.setLineDash([]);
                }

                function dotProduct(v1, v2) {
                  return v1.x * v2.x + v1.y * v2.y;
                }

                function magnitude(v) {
                  return Math.sqrt(v.x * v.x + v.y * v.y);
                }

                function calculateProjection() {
                  // Calcula a proje√ß√£o de U sobre V
                  const magV = magnitude(vectorV);

                  // Evitar divis√£o por zero
                  if (magV < 0.0001) {
                    projectionVector = { x: 0, y: 0 };
                    return 0;
                  }

                  const dotProd = dotProduct(vectorU, vectorV);
                  const scalar = dotProd / (magV * magV);

                  projectionVector = {
                    x: vectorV.x * scalar,
                    y: vectorV.y * scalar,
                  };

                  return magnitude(projectionVector);
                }

                function render() {
                  ctx.clearRect(0, 0, width, height);
                  drawGrid();

                  // Calcular proje√ß√£o
                  const projMagnitude = calculateProjection();

                  // Desenhar vetor V (dire√ß√£o de refer√™ncia)
                  drawVector(
                    vectorV.x,
                    vectorV.y,
                    colors.v,
                    "v",
                    hoverVector === "V",
                  );

                  // Desenhar vetor de proje√ß√£o (sem c√≠rculo manipul√°vel)
                  drawVector(
                    projectionVector.x,
                    projectionVector.y,
                    colors.proj,
                    "proj",
                    false,
                    false,
                  );

                  // Desenhar vetor U (vetor original)
                  drawVector(
                    vectorU.x,
                    vectorU.y,
                    colors.u,
                    "u",
                    hoverVector === "U",
                  );

                  // Desenhar linha de proje√ß√£o
                  drawProjectionLine();

                  // Atualizar valor da proje√ß√£o
                  if (valueDisplay) {
                    valueDisplay.textContent = `|proj| = ${projMagnitude.toFixed(2)}`;
                  }
                }

                function isNearVectorTip(mouseX, mouseY, vector) {
                  const tipX = centerX + vector.x * scale;
                  const tipY = centerY - vector.y * scale;

                  const distance = Math.sqrt(
                    (mouseX - tipX) ** 2 + (mouseY - tipY) ** 2,
                  );
                  return distance < handleRadius;
                }

                function getMousePos(canvas, evt) {
                  const rect = canvas.getBoundingClientRect();
                  // Calcular a posi√ß√£o do mouse relativa ao canvas, considerando qualquer escala
                  const scaleX = canvas.width / rect.width;
                  const scaleY = canvas.height / rect.height;

                  return {
                    x: (evt.clientX - rect.left) * scaleX,
                    y: (evt.clientY - rect.top) * scaleY,
                  };
                }

                function updateCursor(isOverHandle) {
                  canvas.style.cursor = isOverHandle ? "pointer" : "default";
                }

                function checkHover(mouseX, mouseY) {
                  if (isNearVectorTip(mouseX, mouseY, vectorU)) {
                    hoverVector = "U";
                    updateCursor(true);
                    render(); // Re-render para mostrar highlight
                    return true;
                  } else if (isNearVectorTip(mouseX, mouseY, vectorV)) {
                    hoverVector = "V";
                    updateCursor(true);
                    render(); // Re-render para mostrar highlight
                    return true;
                  }

                  if (hoverVector) {
                    hoverVector = null;
                    updateCursor(false);
                    render(); // Re-render para remover highlight
                  }
                  return false;
                }

                // Eventos do mouse - com captura de evento e preven√ß√£o de propaga√ß√£o
                canvas.addEventListener(
                  "mousemove",
                  function (event) {
                    event.stopPropagation(); // Impedir que o Reveal.js capture o evento

                    const mousePos = getMousePos(canvas, event);

                    if (isDragging && selectedVector) {
                      // Convertendo para coordenadas do vetor em rela√ß√£o ao centro
                      const vecX = (mousePos.x - centerX) / scale;
                      const vecY = -(mousePos.y - centerY) / scale; // Inverter Y porque o canvas cresce para baixo

                      // Atualizar o vetor selecionado sem limita√ß√µes artificiais
                      if (selectedVector === "U") {
                        vectorU.x = vecX;
                        vectorU.y = vecY;
                      } else if (selectedVector === "V") {
                        vectorV.x = vecX;
                        vectorV.y = vecY;
                      }

                      render();
                    } else {
                      // Verificar hover
                      checkHover(mousePos.x, mousePos.y);
                    }
                  },
                  true,
                ); // Capturar na fase de captura

                canvas.addEventListener(
                  "mousedown",
                  function (event) {
                    console.log("Canvas mousedown");
                    event.stopPropagation(); // Impedir que o Reveal.js capture o evento
                    event.preventDefault(); // Impedir comportamento padr√£o

                    const mousePos = getMousePos(canvas, event);

                    if (isNearVectorTip(mousePos.x, mousePos.y, vectorU)) {
                      console.log("Selecionando vetor U");
                      isDragging = true;
                      selectedVector = "U";
                      canvas.style.cursor = "grabbing";
                      disableRevealKeyboard(); // Desativar atalhos do Reveal durante o arrasto
                    } else if (
                      isNearVectorTip(mousePos.x, mousePos.y, vectorV)
                    ) {
                      console.log("Selecionando vetor V");
                      isDragging = true;
                      selectedVector = "V";
                      canvas.style.cursor = "grabbing";
                      disableRevealKeyboard(); // Desativar atalhos do Reveal durante o arrasto
                    }

                    // Esconder a dica de intera√ß√£o ap√≥s o primeiro clique
                    if (isDragging && interactionHint) {
                      interactionHint.style.opacity = "0.5";
                    }
                  },
                  true,
                ); // Capturar na fase de captura

                // Usar window para capturar mouse up em qualquer lugar
                window.addEventListener(
                  "mouseup",
                  function (event) {
                    if (isDragging) {
                      console.log("Finalizando arrasto");
                      event.stopPropagation(); // S√≥ impedir propaga√ß√£o se est√°vamos arrastando
                      isDragging = false;
                      selectedVector = null;
                      canvas.style.cursor = hoverVector ? "pointer" : "default";
                      enableRevealKeyboard(); // Reativar atalhos do Reveal ap√≥s o arrasto
                    }
                  },
                  true,
                ); // Capturar na fase de captura

                canvas.addEventListener("mouseleave", function (event) {
                  if (!isDragging) {
                    // N√£o interromper o arrasto se o mouse sair do canvas
                    hoverVector = null;
                    updateCursor(false);
                    render();
                  }
                });

                // Prevenir que cliques no canvas avancem os slides
                canvas.addEventListener(
                  "click",
                  function (event) {
                    event.stopPropagation();
                  },
                  true,
                );

                // Renderiza√ß√£o inicial
                console.log("Renderizando canvas inicial");
                render();
              }
            </script>
          </section>

          <!-- Slide Vertical 3: Aplica√ß√µes e Exemplos -->
          <section>
            <h2>Aplica√ß√µes na Wasteland</h2>

            <div
              style="
                display: flex;
                justify-content: space-between;
                align-items: flex-start;
              "
            >
              <div
                style="
                  flex: 1;
                  padding: 10px;
                  background-color: rgba(0, 0, 0, 0.4);
                  border-radius: 5px;
                  margin-right: 10px;
                "
              >
                <h3 style="color: #ffd700">Trabalho efetivo</h3>
                <p>
                  Quando empurramos um objeto, apenas a componente da for√ßa na
                  dire√ß√£o do movimento gera trabalho √∫til.
                </p>
                <p class="formula">
                  \[ W = \vec{F} \cdot \vec{d} = |\vec{F}||\vec{d}|\cos(\theta)
                  = |\text{proj}_{\vec{d}}\vec{F}||\vec{d}| \]
                </p>
              </div>

              <div
                style="
                  flex: 1;
                  padding: 10px;
                  background-color: rgba(0, 0, 0, 0.4);
                  border-radius: 5px;
                "
              >
                <h3 style="color: #ffd700">Navega√ß√£o t√°tica</h3>
                <p>
                  Decompor uma rota em componentes √∫teis e in√∫teis para
                  determinar progresso real em dire√ß√£o ao objetivo.
                </p>
                <p>
                  <small
                    >Um vetor de deslocamento de 5 km a 60¬∞ da rota principal
                    equivale a um avan√ßo real de apenas 2.5 km.</small
                  >
                </p>
              </div>
            </div>

            <div class="vault-box">
              <h3 class="vault-title">INSIGHT ESTRAT√âGICO</h3>
              <p>
                Quanto mais perpendicular um vetor for √† dire√ß√£o de interesse,
                menor ser√° sua proje√ß√£o e menor sua contribui√ß√£o √∫til naquela
                dire√ß√£o.
              </p>
              <p>
                Vetores paralelos t√™m proje√ß√£o m√°xima; vetores perpendiculares
                t√™m proje√ß√£o zero.
              </p>
            </div>
          </section>

          <!-- Slide Vertical 4: Exerc√≠cio Pr√°tico -->
          <section>
            <h2>Miss√£o T√°tica: Otimiza√ß√£o de Recursos</h2>

            <div
              style="
                background-color: rgba(0, 0, 0, 0.6);
                padding: 15px;
                border: 1px solid #0f0;
                border-radius: 5px;
              "
            >
              <p>
                <strong style="color: #ffd700">Cen√°rio:</strong> Sua equipe
                precisa transportar suprimentos em um terreno inclinado. Voc√™
                tem dois vetores:
              </p>
              <ul>
                <li>
                  Vetor for√ßa dispon√≠vel: \(\vec{F} = (3, 4)\) com m√≥dulo 5
                  unidades
                </li>
                <li>
                  Vetor dire√ß√£o do deslocamento: \(\vec{d} = (5, 0)\)
                  (horizontal)
                </li>
              </ul>

              <p>
                <strong style="color: #ffd700">Objetivos da Miss√£o:</strong>
              </p>
              <ol>
                <li>
                  Calcule a proje√ß√£o de \(\vec{F}\) na dire√ß√£o de \(\vec{d}\)
                  usando \(\frac{\vec{F} \cdot \vec{d}}{|\vec{d}|^2}\vec{d}\)
                </li>
                <li>
                  Determine quanto da sua for√ßa est√° sendo usada efetivamente
                  nesta dire√ß√£o
                </li>
                <li>
                  Calcule o √¢ngulo entre \(\vec{F}\) e \(\vec{d}\) para avaliar
                  a efici√™ncia do trabalho
                </li>
              </ol>
            </div>
          </section>
        </section>

        <!-- Slide Horizontal: M√≥dulo (Comprimento) e Versores -->
        <section>
          <!-- Slide Vertical: Defini√ß√£o do M√≥dulo -->
          <section>
            <h2>M√≥dulo (Comprimento) de um Vetor</h2>
            <p>
              Para medir a intensidade de um vetor \(\vec{v} = (x, y)\) em
              \(\mathbb{R}^2\), utilizamos:
            </p>
            <p class="formula">
              \[ |\vec{v}| = \sqrt{x^2 + y^2} = \sqrt{\vec{v} \cdot \vec{v}} \]
            </p>
            <p class="formula">\[ |\vec{v}|^2 = \vec{v} \cdot \vec{v} \]</p>

            <p>
              Essa f√≥rmula deriva diretamente do Teorema de Pit√°goras,
              considerando \(x\) e \(y\) como os catetos de um tri√¢ngulo
              ret√¢ngulo, cujo comprimento da hipotenusa √© \(|\vec{v}|\).
            </p>
            <p>
              Em aplica√ß√µes pr√°ticas, o m√≥dulo indica a ‚Äúintensidade‚Äù ou ‚Äúfor√ßa‚Äù
              que esse vetor representa (por exemplo, a intensidade de uma for√ßa
              ou velocidade).
            </p>
          </section>

          <!-- Slide Vertical: Versor e Escrita de um Vetor -->
          <section>
            <h2>Versor (Vetor Unit√°rio)</h2>
            <p>
              Qualquer vetor \(\vec{v}\) pode ser decomposto como seu m√≥dulo
              vezes um <em>vetor unit√°rio</em>, tamb√©m chamado de
              <em>versor</em>, que indica apenas a dire√ß√£o e o sentido:
            </p>
            <p class="formula">
              \[ \vec{v} = |\vec{v}|\hat{v}, \quad\text{onde}\quad \hat{v} =
              \frac{\vec{v}}{|\vec{v}|}. \]
            </p>
            <p>
              Assim, <em>\(\hat{v}\)</em> possui m√≥dulo igual a 1 e aponta
              exatamente na dire√ß√£o de \(\vec{v}\). Esse conceito √© √∫til para
              normalizar vetores em diversos c√°lculos, como proje√ß√µes e dire√ß√µes
              de movimento.
            </p>
          </section>

          <!-- Slide Vertical: Base Can√¥nica -->
          <section>
            <h2>Base Can√¥nica em \(\mathbb{R}^2\)</h2>
            <p>
              Em \(\mathbb{R}^2\), a forma mais comum de representar um vetor √©
              usando a base can√¥nica:
            </p>
            <ul>
              <li>\(\hat{i} = (1,0)\)</li>
              <li>\(\hat{j} = (0,1)\)</li>
            </ul>
            <p class="formula">\[ \vec{v} = x \hat{i} + y \hat{j}\]</p>
            <p></p>
            <p class="formula">
              \[ \vec{v} = (\vec{v} \cdot \hat{i}) \hat{i} + (\vec{v} \cdot
              \hat{J}) \hat{j} \]
            </p>
            <p>
              √â outra maneira de ver a mesma informa√ß√£o: em vez de agrupar em um
              par ordenado \((x,y)\), distribu√≠mos as componentes como ‚Äúpesos‚Äù
              dos vetores unit√°rios \(\hat{i}\) e \(\hat{j}\).
            </p>
          </section>

          <!-- Slide Vertical: Exerc√≠cios -->
          <section>
            <h2>Exerc√≠cios</h2>
            <ol>
              <li>
                Calcule o m√≥dulo de \(\vec{u} = (3, -2)\) usando \(\displaystyle
                |\vec{u}| = \sqrt{x^2 + y^2}\). Em seguida, escreva \(\vec{u}\)
                na forma \(|\vec{u}|\hat{u}\).
              </li>
              <li>
                Represente o mesmo vetor \(\vec{u} = (3, -2)\) em fun√ß√£o da base
                can√¥nica, \(\hat{i}\) e \(\hat{j}\).
              </li>
              <li>
                Escolha outro vetor \(\vec{v} = (x, y)\) e repita o processo:
                <ul>
                  <li>Encontre \(|\vec{v}|\).</li>
                  <li>Determine \(\hat{v}\).</li>
                  <li>
                    Escreva \(\vec{v}\) em termos de \(\hat{i}\) e \(\hat{j}\).
                  </li>
                </ul>
              </li>
            </ol>
          </section>
        </section>

        <section>
          <section>
            <h2>Dist√¢ncia entre Pontos: O Mapa da Sobreviv√™ncia</h2>
            <p>
              Em um mundo p√≥s-apocal√≠ptico, saber a dist√¢ncia entre dois pontos
              pode significar a diferen√ßa entre encontrar abrigo seguro ou se
              perder em territ√≥rio hostil. A matem√°tica √© o seu mapa confi√°vel,
              revelando conex√µes espaciais com uma precis√£o implac√°vel.
            </p>
          </section>

          <section>
            <h2>Defini√ß√£o Fundamental: A F√≥rmula da Jornada</h2>
            <p>
              Imagine dois abrigos, nas posi√ß√µes \(A(x_1, y_1)\) e \(B(x_2,
              y_2)\), separados por terrenos incertos. A f√≥rmula a seguir d√° a
              dist√¢ncia no seu GPS:
            </p>

            <div class="formula">
              \[d(A,B) = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\]
            </div>
            <blockquote>
              Esta f√≥rmula √© mais do que uma equa√ß√£o; √© o roteiro para
              atravessar dist√¢ncias <strong>retas</strong>, desenhando pontes
              invis√≠veis entre pontos no vazio. Por√©m, lembre-se: em terrenos
              tortuosos, curvas e obst√°culos desafiam essa simplicidade,
              exigindo outros c√°lculos para medir o verdadeiro trajeto.
            </blockquote>
          </section>

          <section>
            <h2>Vetores e Dist√¢ncia: O Trajeto do Explorador</h2>
            <p>
              Para entender o verdadeiro caminho, precisamos do
              <strong>vetor entre pontos</strong>, o tra√ßo deixado por quem j√°
              fez a travessia:
            </p>

            <div class="formula">
              \[\vec{AB} = \vec{B} - \vec{A} = (x_2 - x_1, y_2 - y_1)\]
            </div>

            <blockquote>
              <strong>Importante:</strong> Embora o vetor represente o caminho
              entre \(A\) e \(B\), ele sempre √© tra√ßado a partir da
              <em>origem</em>, o ponto zero da civiliza√ß√£o.
            </blockquote>
          </section>
          <section>
            <h1>Explorando o terreno:</h1>
            <ul>
              <li>
                üó∫Ô∏è O vetor \(\vec{AB}\) representa o deslocamento entre os
                abrigos \(A\) e \(B\)
              </li>
              <li>
                üìç Suas coordenadas mostram o quanto voc√™ precisa se mover em
                cada dire√ß√£o
              </li>
              <li>
                üö© A dist√¢ncia √© o comprimento deste vetor: \(|\vec{AB}|\)
              </li>
            </ul>
          </section>

          <section>
            <h2>Aplica√ß√µes em Terrenos In√≥spitos</h2>
            <p>
              A dist√¢ncia euclidiana √© a b√∫ssola oculta por tr√°s de muitas
              miss√µes:
            </p>

            <ul>
              <li>
                ü¶† Sobreviv√™ncia biol√≥gica: Mapeamento da propaga√ß√£o de v√≠rus em
                √°reas contaminadas
              </li>
              <li>
                üöÄ Explora√ß√£o espacial: Trajet√≥rias entre esta√ß√µes e planetas
              </li>
              <li>
                ü§ñ Intelig√™ncia artificial: Algoritmos de busca em territ√≥rios
                virtuais
              </li>
            </ul>
          </section>

          <section>
            <h2>Miss√£o Pr√°tica: Navegando no Plano Cartesiano</h2>

            <div class="formula">
              <h3>Desafio do Explorador</h3>
              <ol>
                <li>
                  üìå Marque seus pontos de interesse:
                  <ul>
                    <li>\(A(2, 3)\) - O abrigo inicial</li>
                    <li>\(B(5, 1)\) - O posto avan√ßado</li>
                  </ul>
                </li>
                <li>
                  üó∫Ô∏è Tra√ßando a rota:
                  <ul>
                    <li>
                      Desenhe o plano cartesiano com os pontos \(A\) e \(B\)
                    </li>
                    <li>Calcule o vetor \(\vec{AB}\)</li>
                    <li>Projete o vetor a partir da <strong>origem</strong></li>
                  </ul>
                </li>
              </ol>
            </div>

            <blockquote>
              <strong>Cuidado:</strong> Mesmo que voc√™ esteja viajando de \(A\)
              para \(B\), o vetor \(\vec{AB}\) deve sempre come√ßar na origem,
              onde sua jornada matem√°tica come√ßa.
            </blockquote>

            <div class="formula">
              C√°lculo do vetor: \[\vec{AB} = (5-2, 1-3) = (3, -2)\]
            </div>

            <p>
              üîç An√°lise: Esse vetor √© o rastro da sua jornada, o registro do
              deslocamento necess√°rio para atravessar o territ√≥rio desconhecido.
            </p>
          </section>

          <section>
            <h2>Miss√µes Avan√ßadas para Exploradores Matem√°ticos</h2>
            <ul>
              <li>
                üìè Calcular dist√¢ncias em sistemas de coordenadas alternativos
                (polar, esf√©rico)
              </li>
              <li>
                üöß Identificar onde a m√©trica euclidiana falha, como em terrenos
                n√£o lineares
              </li>
              <li>
                üî≠ Explorar dist√¢ncias em espa√ßos de mais de duas dimens√µes: o
                universo √© maior do que parece
              </li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h1>Paralelismo e Ortogonalidade</h1>
            <h2>Navegando por Vetores em Terras Devastadas</h2>
          </section>

          <section>
            <h2>Fundamentos Conceituais</h2>
            <p>
              Imagine vetores como
              <strong>esquadr√µes de sobreviventes</strong> em um territ√≥rio
              hostil, cada um seguindo sua pr√≥pria rota para encontrar recursos
              essenciais.
            </p>

            <div class="fragment">
              <h3>Vetores Paralelos</h3>
              <p>
                Dois vetores \(\vec{u}\) e \(\vec{v}\) s√£o
                <span class="highlight">paralelos</span> quando um pode ser
                transformado no outro atrav√©s de uma
                <em>multiplica√ß√£o escalar</em>:
              </p>
              <p>\[\vec{u} = k \cdot \vec{v}\]</p>
              <p>
                üí° <em>Analogia de Sobreviv√™ncia</em>: Como trilhas seguras que
                seguem na mesma dire√ß√£o, seja em um deserto radioativo ou entre
                ru√≠nas urbanas, independentemente da dist√¢ncia percorrida.
              </p>
            </div>
          </section>

          <section>
            <h3>Exemplo Pr√°tico de Paralelismo</h3>
            <p>Considere dois vetores em um mapa de zonas de perigo:</p>
            <ul>
              <li>\(\vec{u} = (2, 4)\)</li>
              <li>\(\vec{v} = (1, 2)\)</li>
            </ul>
            <p>
              Observe que \(\vec{u} = 2 \cdot \vec{v}\), portanto, s√£o
              <strong>paralelos</strong> ‚Äî como patrulhas que seguem rotas
              id√™nticas, mas em hor√°rios diferentes.
            </p>
            <div class="fragment">
              <p>
                üîç <em>Teste de Paralelismo</em>: Divida as coordenadas de um
                vetor pelas do outro. Se o resultado for constante, parab√©ns!
                Voc√™ encontrou duas rotas alinhadas.
              </p>
            </div>
          </section>

          <section>
            <h2>Ortogonalidade: Independ√™ncia em Campo de Batalha</h2>
            <p>
              Vetores ortogonais s√£o como
              <strong>esquadr√µes t√°ticos</strong> que operam de forma
              independente, cobrindo √¢ngulos estrat√©gicos sem interferir um no
              outro.
            </p>

            <div class="fragment">
              <h3>Defini√ß√£o Matem√°tica</h3>
              <p>
                Dois vetores \(\vec{u}\) e \(\vec{v}\) s√£o
                <span class="highlight">ortogonais</span> quando seu produto
                interno √© zero:
              </p>
              <p>\[\vec{u} \cdot \vec{v} = 0\]</p>
              <p>
                üí° <em>Interpreta√ß√£o no Campo</em>: Eles formam um √¢ngulo de 90
                graus, garantindo que suas rotas n√£o se cruzem ‚Äî perfeito para
                evitar emboscadas.
              </p>
            </div>
          </section>

          <section>
            <h3>Exemplo de Ortogonalidade</h3>
            <p>Em uma base de opera√ß√µes:</p>
            <ul>
              <li>
                \(\vec{u} = (1, 0)\) - patrulha ao longo da fronteira
                leste-oeste
              </li>
              <li>
                \(\vec{v} = (0, 1)\) - patrulha ao longo da fronteira norte-sul
              </li>
            </ul>
            <p>Calculando o produto interno:</p>
            <p>\[\vec{u} \cdot \vec{v} = (1 \cdot 0) + (0 \cdot 1) = 0\]</p>
            <div class="fragment">
              <p>
                üéØ <em>Consequ√™ncia T√°tica</em>: Esses esquadr√µes n√£o interferem
                um no outro, maximizando a vigil√¢ncia sem sobreposi√ß√£o de
                esfor√ßos.
              </p>
            </div>
          </section>

          <section>
            <h2>Miss√µes de Sobreviv√™ncia</h2>
            <h3>Miss√£o 1: An√°lise de Rota</h3>
            <p>Dados os vetores de movimenta√ß√£o:</p>
            <ul>
              <li>\(\vec{a} = (3, 4)\)</li>
              <li>\(\vec{b} = (4, -3)\)</li>
              <li>\(\vec{c} = (6, 8)\)</li>
            </ul>
            <p>Determine:</p>
            <ol>
              <li>Quais rotas seguem paralelas?</li>
              <li>
                Existe alguma configura√ß√£o ortogonal, ideal para patrulhamento
                estrat√©gico?
              </li>
            </ol>
          </section>

          <section>
            <h3>Miss√£o 2: Sistemas de Navega√ß√£o</h3>
            <p>Em um posto avan√ßado, considere dois sensores:</p>
            <ul>
              <li>Sensor de movimento horizontal: \(\vec{m} = (1, 0)\)</li>
              <li>Sensor de movimento vertical: \(\vec{v} = (0, 1)\)</li>
            </ul>
            <p>
              Por que a ortogonalidade entre esses sensores √© crucial para
              detectar amea√ßas com precis√£o?
            </p>
            <div class="fragment">
              <p>
                üåê <em>Reflex√£o de Campo</em>: Sensores ortogonais garantem que
                nenhum movimento escape √† vigil√¢ncia, cobrindo √¢ngulos mortos de
                forma eficiente.
              </p>
            </div>
          </section>

          <section>
            <h2>Reflex√£o Final</h2>
            <blockquote>
              <p>
                Em um mundo onde a sobreviv√™ncia depende da estrat√©gia, a
                ortogonalidade n√£o √© apenas um conceito matem√°tico, mas um
                princ√≠pio de efici√™ncia e independ√™ncia.
              </p>
            </blockquote>
            <p>
              Assim como esquadr√µes que operam de forma independente podem
              proteger uma base com efic√°cia, indiv√≠duos com habilidades
              complementares criam comunidades resilientes em tempos de crise.
            </p>
          </section>
        </section>

        <section>
          <section>
            <h1>√Årea de Tri√¢ngulos Vetoriais</h1>
            <h2>Decodificando Espa√ßos, Revelando Estrat√©gias</h2>
          </section>

          <section>
            <h2>Territ√≥rios Delimitados por Vetores</h2>
            <p>
              Imagine dois vetores, \(\vec{u}\) e \(\vec{v}\), como
              <strong>fronteiras invis√≠veis</strong> tra√ßando os limites de um
              territ√≥rio em disputa.
            </p>

            <div class="fragment formula">
              <h3>F√≥rmula Fundamental</h3>
              <p>
                \[\text{√Årea} = \frac{1}{2} |\vec{u}| |\vec{v}| \sin(\theta)\]
              </p>
              <p>
                üîç <em>Intui√ß√£o Estrat√©gica</em>: A √°rea emerge da combina√ß√£o da
                for√ßa (magnitude) e do √¢ngulo (desalinhamento) entre os vetores.
              </p>
            </div>

            <div class="fragment">
              <p>üìê <strong>Elementos Essenciais</strong>:</p>
              <ul>
                <li>
                  \(|\vec{u}|\) e \(|\vec{v}|\): Intensidade dos "movimentos"
                </li>
                <li>
                  \(\sin(\theta)\): O grau de diverg√™ncia entre as dire√ß√µes
                </li>
              </ul>
            </div>
          </section>

          <section>
            <h2>Relacionando F√≥rmulas Conhecidas</h2>
            <p>Lembre-se da f√≥rmula cl√°ssica da √°rea de um tri√¢ngulo:</p>
            <p>
              \[ \text{√Årea} = \frac{\text{base} \times \text{altura}}{2} \]
            </p>
            <p>
              Se considerarmos \(|\vec{u}|\) como a base, ent√£o \(|\vec{v}|
              \sin(\theta)|\) √© a altura ‚Äî afinal, o m√≥dulo de um vetor vezes o
              seno do √¢ngulo entre eles nos d√° a altura do tri√¢ngulo.
            </p>

            <div class="fragment">
              <p>üìè <strong>Conex√£o com Vetores:</strong></p>
              <ul>
                <li>\( \text{base} = |\vec{u}| \)</li>
                <li>\( \text{altura} = |\vec{v}| \sin(\theta) \)</li>
              </ul>
            </div>
          </section>

          <section>
            <h2>Determinantes e √Åreas</h2>
            <p>
              A √°rea do <strong>paralelogramo</strong> definido por dois vetores
              \(\vec{u}\) e \(\vec{v}\) pode ser calculada usando o determinante
              da matriz formada por esses vetores:
            </p>
            <p>
              \[ \text{√Årea do Paralelogramo} = | \det \begin{bmatrix} u_x & v_x
              \\ u_y & v_y \end{bmatrix} | \]
            </p>
            <p>
              Para encontrar a √°rea do tri√¢ngulo formado por esses vetores,
              basta dividir o resultado por 2:
            </p>
            <p>
              \[ \text{√Årea do Tri√¢ngulo} = \frac{1}{2} | \det \begin{bmatrix}
              u_x & v_x \\ u_y & v_y \end{bmatrix} | \]
            </p>

            <div class="fragment">
              <blockquote>
                "O determinante n√£o √© s√≥ um n√∫mero ‚Äî √© a medida do "espa√ßo"
                criado por dois vetores."
              </blockquote>
            </div>
          </section>

          <section>
            <h2>Miss√£o de Reconhecimento</h2>
            <p>Vetores em campo:</p>
            <ul>
              <li>\(\vec{u} = (3, 4)\) com m√≥dulo \(|\vec{u}| = 5\)</li>
              <li>\(\vec{v} = (1, 2)\) com m√≥dulo \(|\vec{v}| = \sqrt{5}\)</li>
            </ul>

            <div class="fragment">
              <h3>Plano de A√ß√£o</h3>
              <ol>
                <li>Calcular o determinante da matriz formada pelos vetores</li>
                <li>
                  Aplicar a f√≥rmula \( \text{√Årea} = \frac{1}{2} |\det| \)
                </li>
                <li>
                  Comparar o resultado com a f√≥rmula \( \frac{1}{2} |\vec{u}|
                  |\vec{v}| \sin(\theta) \)
                </li>
              </ol>
            </div>
          </section>

          <section>
            <h2>Decodifica√ß√£o Matem√°tica</h2>
            <p>Etapas do c√°lculo:</p>
            <ul>
              <li>Produto escalar para encontrar \(\cos(\theta)\)</li>
              <li>\(\sin(\theta) = \sqrt{1 - \cos^2(\theta)}\)</li>
              <li>
                √Årea = \(\frac{1}{2} |\vec{u}| |\vec{v}| \sin(\theta)\)
                <strong>ou</strong> \(\frac{1}{2} |\det|\)
              </li>
            </ul>

            <div class="fragment">
              <p>
                üéØ <strong>Resultado:</strong> O mesmo "territ√≥rio", apenas
                medido de formas diferentes.
              </p>
            </div>
          </section>

          <section>
            <h2>Desafio de Campo</h2>
            <p>Vetores em jogo:</p>
            <ul>
              <li>\(\vec{a} = (2, 2)\)</li>
              <li>\(\vec{b} = (3, -3)\)</li>
            </ul>
            <p>Tarefas:</p>
            <ol>
              <li>Calcular a √°rea do tri√¢ngulo usando o determinante</li>
              <li>
                Confirmar o resultado com a f√≥rmula da √°rea \( \frac{1}{2}
                |\vec{a}| |\vec{b}| \sin(\theta) \)
              </li>
              <li>
                Interpretar o significado geom√©trico do resultado (o que esse
                "territ√≥rio" representa?)
              </li>
            </ol>
          </section>

          <section>
            <h2>Reflex√µes T√°ticas</h2>
            <p>O que a √°rea de um tri√¢ngulo vetorial pode simbolizar?</p>
            <ul>
              <li>Zonas de influ√™ncia entre for√ßas</li>
              <li>Potencial de cobertura territorial</li>
              <li>Pontos cr√≠ticos de interse√ß√£o estrat√©gica</li>
            </ul>

            <div class="fragment">
              <blockquote>
                "Na geometria, cada √°rea √© um espa√ßo de possibilidades ‚Äî e cada
                f√≥rmula, uma nova perspectiva."
              </blockquote>
            </div>
          </section>

          <section>
            <h2>Conclus√£o Estrat√©gica</h2>
            <p>
              A √°rea de um tri√¢ngulo vetorial n√£o √© apenas um n√∫mero. √â a
              <strong>s√≠ntese de for√ßas, dire√ß√µes e possibilidades</strong>.
              Seja atrav√©s do determinante ou da f√≥rmula cl√°ssica, o importante
              √© compreender que tudo se conecta, como diferentes pe√ßas do mesmo
              quebra-cabe√ßa.
            </p>
          </section>
        </section>

        <!-- Slide Horizontal 6: Fechamento -->
        <section>
          <h2>Fechamento</h2>
          <p>
            No fim do dia, nem todo confronto precisa explodir um bunker; √†s
            vezes, descobrir o alinhamento (produto escalar) entre fac√ß√µes pode
            ser o in√≠cio de uma negocia√ß√£o vi√°vel.
          </p>
          <p>
            <em>Reflex√£o:</em> Em um mundo devastado, coopera√ß√£o e respeito aos
            limites alheios (ortogonais) podem evitar
            <strong>jogos de soma zero</strong>. A soma das for√ßas pode ser mais
            valiosa que um embate destrutivo.
          </p>
        </section>
      </div>
      <!-- .slides -->
    </div>
    <!-- .reveal -->

    <!-- Reveal.js -->
    <script src="https://unpkg.com/reveal.js/dist/reveal.js"></script>

    <!-- Reveal Plugins -->
    <script src="https://unpkg.com/reveal.js/plugin/notes/notes.js"></script>
    <script src="https://unpkg.com/reveal.js/plugin/highlight/highlight.js"></script>

    <!-- MathJax -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [["\\(", "\\)"]],
          displayMath: [["\\[", "\\]"]],
        },
        svg: { fontCache: "global" },
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    <script>
      Reveal.initialize({
        hash: true,
        slideNumber: true,
        plugins: [RevealNotes, RevealHighlight],
      });
    </script>
  </body>
</html>
