<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <title>Cap. III — Equações da Reta</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="https://unpkg.com/reveal.js/dist/theme/black.css" id="theme" />
    <link rel="stylesheet" href="https://unpkg.com/reveal.js/plugin/highlight/monokai.css" />
    <link rel="stylesheet" href="../styles.css" />
    <style>
      /* ==================== 
         ESTILOS BASE PARA ELEMENTOS REVEAL (Mantidos do CSS anterior)
         ==================== */
      .reveal h1 {
        font-size: 2.8rem;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        color: #ffd700;
        margin-bottom: 0.3em;
        letter-spacing: 0px;
      }
      .reveal h2 {
        font-size: 2.4rem;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        color: #ffd700;
        margin-bottom: 0.3em;
        letter-spacing: 0px;
      }
      .reveal h3 {
        font-size: 2rem;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        color: #ffd700;
        margin-bottom: 0.2em;
        letter-spacing: 0px;
      }
      .reveal h4 {
        font-size: 1.6rem;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
        color: #ffd700;
        margin-bottom: 0.15em;
        letter-spacing: 0px;
      }
      .reveal section p {
        font-size: 1.4rem;
        line-height: 1.3;
        margin-bottom: 0.4em;
        color: #e0e0e0;
        letter-spacing: 0px;
      }
      .reveal section blockquote {
        font-size: 1.4rem;
        line-height: 1.3;
        font-style: italic;
        border-left: 3px solid #ffd700;
        padding-left: 0.8em;
        margin: 0.8em 0;
        background-color: rgba(50, 50, 50, 0.3);
      }
      .reveal .formula {
        color: #adff2f;
        font-weight: bold;
        font-size: 1.2rem;
        text-align: center;
        margin: 0.6em 0;
        font-family: "Courier New", monospace;
      }
      .reveal section ul {
        list-style: none;
        padding-left: 1.8rem;
        margin: 0.2em 0;
      }
      .reveal section ul li {
        font-size: 1.4rem;
        line-height: 1.3;
        position: relative;
        margin-bottom: 0.4em;
        color: #e0e0e0;
      }
      .reveal section ul li::before {
        content: "☢️";
        position: absolute;
        left: -2.3rem;
        font-size: 1.4rem;
        line-height: 1.3;
      }
      .reveal section ol {
        list-style: none;
        counter-reset: radCounter;
        padding-left: 1.8rem;
        margin: 0.2em 0;
      }
      .reveal section ol li {
        counter-increment: radCounter;
        font-size: 1.4rem;
        line-height: 1.3;
        position: relative;
        margin-bottom: 0.4em;
        color: #e0e0e0;
      }
      .reveal section ol li::before {
        content: "☢️" counter(radCounter) ". ";
        position: absolute;
        left: -3.2rem;
        font-size: 1.4rem;
        line-height: 1.3;
      }
      /* ==================== ESTILOS TEMÁTICOS ADAPTADOS (Mantidos do CSS anterior) ==================== */
      .title-screen {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 85vh;
        background: radial-gradient(
          circle,
          rgba(0, 0, 0, 0) 0%,
          rgba(0, 100, 0, 0.1) 100%
        );
        position: relative;
      }
      .title-screen .subtitle {
        color: #adff2f;
        font-size: 2rem;
        margin-top: -0.3em;
      }
      .emblem-number {
        font-size: 2.6rem;
        font-weight: bold;
        color: #ffd700;
        margin: 0.8em auto;
      }
      .subtitle-warning {
        color: #ff6347;
        border-top: 1px solid #ff6347;
        border-bottom: 1px solid #ff6347;
        padding: 0.4em 0.8em;
        margin-top: 1.5em;
        font-weight: bold;
        font-size: 1.2rem;
        letter-spacing: 0px;
      }
      .mission-briefing {
        padding: 15px;
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 5px;
        margin-bottom: 20px;
      }
      .mission-subtitle {
        color: #adff2f !important;
        font-size: 1.8rem !important;
        margin-top: -0.3em !important;
      }
      .mnemonic {
        font-style: italic;
        background-color: rgba(173, 255, 47, 0.1);
        padding: 0.4em;
        border-left: 3px solid #adff2f;
        margin: 0.8em 0;
        font-size: 1.3rem !important;
      }
      .definition-box {
        background-color: rgba(0, 0, 0, 0.3);
        padding: 0.8em;
        margin-top: 1.2em;
        border-radius: 3px;
      }
      .field-report {
        position: relative;
      }
      .info-panel {
        background-color: #1a1a1a;
        padding: 15px;
        margin: 15px auto;
        width: 85%;
        max-width: 650px;
        box-shadow: inset 0 0 15px #adff2f;
      }
      .info-screen {
        background-color: #000;
        color: #adff2f;
        padding: 12px;
        border-radius: 3px;
        font-family: "Courier New", monospace;
        position: relative;
      }
      .info-screen h4 {
        color: #adff2f !important;
        font-size: 1.6rem !important;
        margin-bottom: 0.4em !important;
        font-family: "Courier New", monospace !important;
      }
      .info-screen ul li {
        color: #adff2f !important;
        font-size: 1.2rem !important;
        line-height: 1.2;
        margin-bottom: 0.3em;
      }
      .info-screen ul li::before {
        font-size: 1.2rem !important;
        line-height: 1.2;
        left: -2rem;
      }
      .info-screen p {
        font-size: 1.2rem !important;
        line-height: 1.2;
        font-family: "Courier New", monospace !important;
        color: #adff2f !important;
      }
      .info-screen::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
          0deg,
          rgba(0, 255, 0, 0.03),
          rgba(0, 255, 0, 0.03) 1px,
          transparent 1px,
          transparent 2px
        );
        pointer-events: none;
      }
      .survival-tip {
        background-color: rgba(255, 215, 0, 0.1);
        border: 1px dashed #ffd700;
        padding: 0.4em 0.8em;
        margin-top: 0.8em;
        border-radius: 3px;
      }
      .survival-tip p {
        font-size: 1.2rem !important;
        font-weight: bold;
        color: #ffd700 !important;
      }
      .simulator {
        text-align: center;
      }
      .canvas-container {
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 3px;
        padding: 8px;
        margin: 15px auto;
        width: 90%;
        max-width: 800px;
        position: relative;
      }
      .canvas-container canvas {
        max-width: 100%;
        height: 400px;
        background-color: rgba(0, 0, 0, 0.3);
      }
      .simulator-controls {
        background-color: #2f2f2f;
        padding: 5px;
        border-radius: 0 0 3px 3px;
        margin-top: 5px;
      }
      .control-panel {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .control-panel label {
        color: #adff2f;
        font-weight: bold;
        font-family: "Courier New", monospace;
        font-size: 0.9rem;
      }
      .control-panel input[type="range"] {
        width: 120px;
        accent-color: #adff2f;
        margin: 0 5px;
      }
      .control-panel input[type="number"] {
        width: 60px;
        background-color: #2f2f2f;
        color: #adff2f;
        border: 1px solid #adff2f;
        padding: 3px;
        border-radius: 3px;
        font-family: "Courier New", monospace;
      }
      .control-panel span {
        color: #adff2f;
        font-family: "Courier New", monospace;
        background-color: #000;
        padding: 1px 3px;
        border-radius: 2px;
        min-width: 20px;
        text-align: center;
        display: inline-block;
        font-size: 0.9rem;
      }
      .operation-btn,
      .preset-button {
        background-color: #2f2f2f;
        color: #adff2f;
        border: 1px solid #adff2f;
        padding: 3px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 0.9rem;
        margin: 0 3px;
      }
      .operation-btn:hover,
      .preset-button:hover {
        background-color: #3f3f3f;
        box-shadow: 0 0 5px #adff2f;
      }
      .operation-btn.active {
        background-color: #adff2f;
        color: #000;
      }
      .hint-message {
        font-style: italic;
        margin-top: 0.8em;
        color: #adff2f;
        font-size: 1.1rem !important;
      }
      .hint-message p {
        color: #adff2f !important;
        font-size: 0.9rem !important;
      }
      .preset-buttons {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 15px;
        flex-wrap: wrap;
      }
      .preset-button.perpendicular {
        color: #00ffff;
        border: 1px solid #00ffff;
      }
      .preset-button.perpendicular:hover {
        background-color: rgba(0, 255, 255, 0.2);
      }
      .preset-button.concurrent {
        color: #ff6347;
        border: 1px solid #ff6347;
      }
      .preset-button.concurrent:hover {
        background-color: rgba(255, 99, 71, 0.2);
      }
      .preset-button.parallel {
        color: #ffd700;
        border: 1px solid #ffd700;
      }
      .preset-button.parallel:hover {
        background-color: rgba(255, 215, 0, 0.2);
      }
      .preset-button.coincident {
        color: #adff2f;
        border: 1px solid #adff2f;
      }
      .preset-button.coincident:hover {
        background-color: rgba(173, 255, 47, 0.2);
      }
      .intersecao-info {
        text-align: center;
        font-size: 1.2rem;
        margin: 15px 0;
        padding: 10px;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 3px;
        font-family: "Courier New", monospace;
      }
      .survival-training {
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 3px;
        padding: 12px;
      }
      .training-problem {
        background-color: rgba(255, 255, 255, 0.05);
        padding: 12px;
        border-radius: 3px;
        border-left: 3px solid #ffd700;
        margin-bottom: 0.8em;
      }
      .problem-context {
        background-color: rgba(255, 0, 0, 0.1);
        padding: 8px;
        border-radius: 3px;
        border: 1px dashed #ff6347;
        font-style: italic;
        margin-top: 0.8em;
      }
      .problem-context p {
        color: #ff6347 !important;
        font-size: 1.2rem !important;
      }
      .debriefing {
        text-align: center;
      }
      .summary-box {
        background-color: rgba(0, 0, 0, 0.2);
        padding: 12px;
        border-radius: 3px;
        margin: 0.8em auto;
        max-width: 85%;
      }
      .summary-box ul li {
        font-size: 1.2rem !important;
        line-height: 1.2;
      }
      .summary-box ul li::before {
        font-size: 1.2rem !important;
        line-height: 1.2;
        left: -2rem;
      }
      .next-mission {
        background-color: rgba(173, 255, 47, 0.1);
        padding: 8px;
        border-radius: 3px;
        margin: 0.8em auto;
        max-width: 85%;
      }
      .next-mission p {
        color: #adff2f !important;
        font-weight: bold;
      }
      .instructor-note {
        font-style: italic;
        margin-top: 1.5em;
        padding: 8px;
        background-color: rgba(255, 215, 0, 0.1);
        border-radius: 3px;
      }
      .instructor-note p {
        color: #ffd700 !important;
        font-size: 1.2rem !important;
      }
      .conversion-panel {
        background-color: rgba(0, 0, 0, 0.3);
        padding: 15px;
        border-radius: 5px;
        margin: 20px 0;
        border-left: 3px solid #adff2f;
      }
      .conversion-title {
        color: #adff2f;
        font-size: 1.4rem;
        margin-bottom: 10px;
        font-weight: bold;
      }
      .conversion-step {
        margin-bottom: 10px;
        padding: 10px;
        background-color: rgba(50, 50, 50, 0.3);
        border-radius: 3px;
      }
      .conversion-step p:first-child {
        font-weight: bold;
        color: #ffd700;
        margin-bottom: 0.3em;
      }
      .table-container {
        width: 100%;
        overflow-x: auto;
        margin: 20px 0;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        background-color: rgba(0, 0, 0, 0.3);
        font-size: 1.1rem;
      }
      th,
      td {
        padding: 8px;
        text-align: left;
        border-bottom: 1px solid #444;
      }
      th {
        background-color: #2a2a2a;
        color: #adff2f;
        font-family: "Courier New", monospace;
      }
      table .reveal section ul li,
      table ul li {
        font-size: 1.1rem !important;
        margin-bottom: 0.2em;
        line-height: 1.2;
      }
      table .reveal section ul li::before,
      table ul li::before {
        font-size: 1.1rem !important;
        left: -2rem;
        line-height: 1.2;
      }
      tr:hover {
        background-color: rgba(173, 255, 47, 0.1);
      }
      .positions-panel {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin: 20px 0;
      }
      .position-card {
        flex: 1;
        min-width: 200px;
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 5px;
        padding: 15px;
        position: relative;
        overflow: hidden;
      }
      /* Ajuste SVG Size */
      .position-card svg {
        width: 90%;
        max-width: 180px;
        height: 100px;
        display: block;
        margin: 5px auto 10px auto;
        stroke-linecap: round;
      }
      .position-card.perpendicular {
        border-left: 3px solid #00ffff;
      }
      .position-card.concurrent {
        border-left: 3px solid #ff6347;
      }
      .position-card.parallel {
        border-left: 3px solid #ffd700;
      }
      .position-card.coincident {
        border-left: 3px solid #adff2f;
      }
      .position-title {
        font-size: 1.3rem;
        margin-bottom: 10px;
        font-weight: bold;
      }
      .position-card.perpendicular .position-title {
        color: #00ffff;
      }
      .position-card.concurrent .position-title {
        color: #ff6347;
      }
      .position-card.parallel .position-title {
        color: #ffd700;
      }
      .position-card.coincident .position-title {
        color: #adff2f;
      }
      .position-desc {
        font-size: 1.1rem;
        margin-bottom: 5px;
      }
      /* Ajuste LaTeX - Mover para dentro da descrição */
      .position-desc .formula {
        font-size: 1rem; /* Menor */
        display: inline;
        margin: 0;
        padding: 0 0.2em;
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 2px;
      }
      .position-condition {
        font-family: "Courier New", monospace;
        background-color: rgba(0, 0, 0, 0.5);
        padding: 5px;
        border-radius: 3px;
        font-size: 1rem;
        margin-top: 10px;
      }
      .visual-diagram {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-around;
        margin: 20px 0;
        gap: 20px;
      }
      .diagram-container {
        flex: 1;
        min-width: 300px;
        background-color: rgba(0, 0, 0, 0.3);
        padding: 15px;
        border-radius: 5px;
        text-align: center;
      }
      .diagram-container svg {
        width: 100%;
        max-width: 300px;
        height: auto;
        max-height: 200px;
        display: block;
        margin: 10px auto;
      }
      .diagram-container p {
        font-size: 1.1rem !important;
        line-height: 1.2;
      }
      .diagram-title {
        color: #ffd700;
        font-size: 1.2rem;
        margin-bottom: 10px;
      }
      .case-study {
        margin: 20px 0;
        padding: 15px;
        background-color: rgba(0, 0, 0, 0.2);
        border-radius: 5px;
      }
      .case-title {
        color: #ffd700;
        font-size: 1.4rem;
        margin-bottom: 10px;
      }
      .case-description {
        margin-bottom: 15px;
      }
      .case-solution {
        background-color: rgba(0, 0, 0, 0.3);
        padding: 10px;
        border-radius: 3px;
        margin-top: 10px;
      }
      .case-solution-title {
        color: #adff2f;
        font-size: 1.2rem;
        margin-bottom: 5px;
      }
      .case-step {
        margin-bottom: 0.8em;
        padding-left: 1em;
        border-left: 2px solid rgba(173, 255, 47, 0.3);
      }
      .case-step strong {
        color: #ffd700;
      }
      .two-column {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        margin: 20px 0;
      }
      .column {
        flex: 1;
        min-width: 300px;
        background-color: rgba(0, 0, 0, 0.3);
        padding: 15px;
        border-radius: 5px;
      }
      .column-title {
        color: #ffd700;
        font-size: 1.3rem;
        margin-bottom: 10px;
        border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        padding-bottom: 5px;
      }
      .level-basic {
        border-left: 4px solid #4682b4;
      }
      .level-intermediate {
        border-left: 4px solid #ffd700;
      }
      .level-advanced {
        border-left: 4px solid #ff6347;
      }
      .level-indicator {
        font-size: 1.1rem;
        padding: 2px 6px;
        border-radius: 2px;
        margin-left: 8px;
        font-weight: bold;
        display: inline-block;
      }
      .level-basic .level-indicator {
        background-color: #4682b4;
        color: white;
      }
      .level-intermediate .level-indicator {
        background-color: #ffd700;
        color: black;
      }
      .level-advanced .level-indicator {
        background-color: #ff6347;
        color: white;
      }
      .crt-effect {
        position: relative;
        overflow: hidden;
      }
      .crt-effect::after {
        content: "";
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          rgba(18, 16, 16, 0) 50%,
          rgba(0, 0, 0, 0.1) 50%
        );
        background-size: 100% 4px;
        pointer-events: none;
        z-index: 10;
      }
      .interactive-element {
        cursor: pointer;
        position: relative;
      }
      .interactive-element::after {
        content: "";
        position: absolute;
        top: -3px;
        left: -3px;
        right: -3px;
        bottom: -3px;
        border: 1px solid #adff2f;
        border-radius: 3px;
        animation: pulse 2s infinite;
        pointer-events: none;
      }
      @keyframes pulse {
        0% {
          opacity: 0.2;
          transform: scale(1);
        }
        50% {
          opacity: 0.5;
          transform: scale(1.03);
        }
        100% {
          opacity: 0.2;
          transform: scale(1);
        }
      }
      .radiation-glow {
        text-shadow:
          0 0 5px #adff2f,
          0 0 10px #adff2f;
        transition: text-shadow 0.3s ease;
      }
      .radiation-glow:hover {
        text-shadow:
          0 0 10px #adff2f,
          0 0 15px #adff2f,
          0 0 20px #adff2f;
      }
      .tutorial-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      .tutorial-content {
        background-color: #1a1a1a;
        border: 2px solid #adff2f;
        padding: 20px;
        max-width: 400px;
        text-align: center;
        color: #e0e0e0;
        box-shadow: 0 0 15px rgba(173, 255, 47, 0.5);
      }
      .tutorial-close-btn {
        background-color: #2f2f2f;
        color: #adff2f;
        border: 1px solid #adff2f;
        padding: 5px 15px;
        margin-top: 15px;
        cursor: pointer;
        font-family: "Courier New", monospace;
      }
      .tutorial-close-btn:hover {
        background-color: #3f3f3f;
        box-shadow: 0 0 5px #adff2f;
      }
      .highlight-spd {
        background-color: rgba(0, 255, 255, 0.1);
        border-left: 2px solid #00ffff;
        padding: 0.1em 0.3em;
      }
      .highlight-si {
        background-color: rgba(255, 215, 0, 0.1);
        border-left: 2px solid #ffd700;
        padding: 0.1em 0.3em;
      }
      .highlight-spi {
        background-color: rgba(173, 255, 47, 0.1);
        border-left: 2px solid #adff2f;
        padding: 0.1em 0.3em;
      }
      /* Media Queries (Mantidos do CSS anterior) */
      @media screen and (max-width: 1024px) {
        .reveal h1 {
          font-size: 2.4rem;
        }
        .reveal h2 {
          font-size: 2.1rem;
        }
        .reveal h3 {
          font-size: 1.8rem;
        }
        .reveal section p {
          font-size: 1.3rem;
        }
        .reveal .formula {
          font-size: 1.1rem;
        }
        .reveal section ul li,
        .reveal section ol li {
          font-size: 1.3rem;
        }
        .info-panel {
          width: 95%;
        }
        .info-screen ul li {
          font-size: 1.1rem !important;
        }
        .control-panel label,
        .control-panel span,
        .operation-btn {
          font-size: 0.8rem;
        }
        .control-panel input[type="range"] {
          width: 100px;
        }
        table {
          font-size: 1rem;
        }
        table .reveal section ul li,
        table ul li {
          font-size: 1rem !important;
        }
      }
      @media screen and (max-width: 768px) {
        .reveal h1 {
          font-size: 2.2rem;
        }
        .reveal h2 {
          font-size: 1.9rem;
        }
        .reveal h3 {
          font-size: 1.6rem;
        }
        .reveal section p {
          font-size: 1.2rem;
        }
        .reveal .formula {
          font-size: 1rem;
        }
        .reveal section ul li,
        .reveal section ol li {
          font-size: 1.2rem;
        }
        .info-screen ul li {
          font-size: 1rem !important;
        }
        .control-panel {
          flex-direction: column;
          align-items: flex-start;
          gap: 5px;
        }
        .emblem-number {
          width: 100px;
          height: 100px;
          font-size: 2.2rem;
        }
        .control-panel label,
        .control-panel span,
        .operation-btn,
        .preset-button {
          font-size: 0.8rem;
        }
        .control-panel input[type="range"] {
          width: 150px;
        }
        .control-panel input[type="number"] {
          width: 50px;
        }
        table {
          font-size: 0.9rem;
        }
        table th,
        table td {
          padding: 6px;
        }
        table .reveal section ul li,
        table ul li {
          font-size: 0.9rem !important;
        }
        table .reveal section ul li::before,
        table ul li::before {
          left: -1.8rem;
        }
        .visual-diagram,
        .two-column {
          flex-direction: column;
        }
        .diagram-container,
        .column {
          min-width: 80%;
          margin-bottom: 15px;
        }
        .positions-panel {
          flex-direction: column;
        }
        .position-card {
          min-width: 80%;
        }
      }
    </style>

  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- Slide de Título do Capítulo (Horizontal 1) -->
        <section>
          <div class="title-screen">
            <h1>Capítulo III: O Estudo da Reta</h1>
            <h2 class="subtitle">Traçando Rotas no Espaço Conhecido</h2>
            <div class="emblem-number">GA-103</div>
            <p class="subtitle-warning">PROTOCOLO DE NAVEGAÇÃO ESSENCIAL</p>
          </div>
        </section>

        <!-- Slide de Contexto Histórico Geral (Horizontal 2) -->
        <section class="mission-briefing">
          <h2>Contexto: A Conquista do Espaço (e da Sobrevivência)</h2>
          <h3 class="mission-subtitle">Da Antiguidade às Estrelas</h3>
          <p>
            Desde os primeiros mapas terrestres até as complexas trajetórias
            interplanetárias, a Geometria Analítica, formalizada por Descartes e
            Fermat, foi a chave para descrever o espaço matematicamente.
          </p>
          <div class="info-panel">
            <div class="info-screen crt-effect">
              <p>Entender retas, planos e curvas permitiu:</p>
              <ul>
                <li>Navegação precisa nos oceanos.</li>
                <li>Desenho de fortificações e cidades.</li>
                <li>Cálculo de órbitas de planetas e satélites.</li>
                <li>
                  Mapeamento de terrenos (essencial para reconstrução ou
                  exploração).
                </li>
              </ul>
            </div>
          </div>
          <p>
            Dominar estas ferramentas é dominar a capacidade de se localizar,
            planejar e prever em qualquer ambiente, seja ele a Terra devastada
            ou a vastidão do espaço.
          </p>
        </section>

        <!-- Tópico 1: Equações da Reta (Horizontal 3) -->
        <section>
          <!-- 1.1 Conceito Principal -->
          <section class="mission-briefing">
            <h2>Tópico 1: Equações da Reta</h2>
            <h3 class="mission-subtitle">As Múltiplas Faces de um Caminho</h3>
            <div class="definition-box">
              <p>
                <strong>Definição Formal:</strong> Uma reta no plano é um
                conjunto de pontos (x, y) que satisfazem uma equação linear.
              </p>
              <p>
                <strong>Interpretação Física/Espacial:</strong> Representa um
                caminho reto e infinito, uma direção constante, uma fronteira ou
                uma trajetória idealizada sem desvios.
              </p>
            </div>
            <p>
              Existem várias formas de descrever a mesma reta, cada uma útil
              para diferentes análises táticas.
            </p>
            <p class="mnemonic">
              "Uma rota, várias linguagens matemáticas. Fale todas."
            </p>
          </section>

          <!-- 1.2 Visualizações (Adaptação do slide anterior) -->
          <section>
            <h3>As Três Representações Principais</h3>
            <div class="two-column">
              <div class="column">
                <div class="column-title">Forma Reduzida</div>
                <p class="formula">\( y = mx + b \)</p>
                <p>\(m\): inclinação, \(b\): intercepto Y.</p>
                <p>Ideal para visualização rápida.</p>
              </div>
              <div class="column">
                <div class="column-title">Forma Geral</div>
                <p class="formula">\( Ax + By + C = 0 \)</p>
                <p>\(A, B, C\): coeficientes.</p>
                <p>Representa todas as retas.</p>
              </div>
            </div>
            <div class="definition-box" style="margin-top: 1em">
              <p class="formula" style="text-align: center">
                \( \begin{cases} x = x_0 + at \\ y = y_0 + bt \end{cases} \)
                (Forma Paramétrica)
              </p>
              <p style="text-align: center">
                \( (x_0, y_0) \): ponto inicial, \( (a, b) \): vetor diretor,
                \(t\): parâmetro (tempo/distância).
              </p>
            </div>
          </section>

          <!-- 1.3 Teorema/Propriedade Relacionada (Unicidade e Conversões) -->
          <section class="field-report level-basic">
            <h3>Teoria: Equivalência das Formas</h3>
            <p>
              Embora pareçam diferentes, as formas (Geral, Reduzida,
              Paramétrica) podem descrever a *mesma* reta (com exceção das
              verticais para a Reduzida).
            </p>
            <div class="info-panel">
              <div class="info-screen crt-effect">
                <h4>Conversibilidade:</h4>
                <ul>
                  <li>Geral ⇔ Reduzida (se \(B \neq 0\)).</li>
                  <li>Geral ⇔ Paramétrica (usando vetores normal/diretor).</li>
                  <li>Paramétrica ⇒ Geral (eliminando o parâmetro \(t\)).</li>
                </ul>
                <p>
                  A capacidade de converter entre formas é essencial para
                  escolher a ferramenta certa para cada problema de navegação ou
                  análise.
                </p>
              </div>
            </div>
          </section>

          <!-- NOVO Slide: Exemplo de Conversão -->
          <section class="field-report level-basic">
            <h3>Exemplo de Conversão: Geral para Reduzida</h3>
            <div class="conversion-panel">
              <div class="conversion-step">
                <p>Reta (Geral): \( 2x + 4y - 8 = 0 \)</p>
              </div>
              <div class="conversion-step">
                <p>Passo 1: Isolar \(y\): \( 4y = -2x + 8 \)</p>
              </div>
              <div class="conversion-step">
                <p>
                  Passo 2: Dividir por 4: \( y = -\frac{2}{4}x + \frac{8}{4} \)
                </p>
                <p class="formula">\( y = -0.5x + 2 \)</p>
                <p>(\(m = -0.5\), \(b = 2\))</p>
              </div>
            </div>
            <div class="survival-tip">
              <p>
                DICA: Pratique as conversões! Ser ágil na mudança de forma é
                útil sob pressão.
              </p>
            </div>
          </section>

          <!-- 1.4 Problema -> Agora Simulador -->
          <section class="simulator">
            <h3>Visualização Interativa: As Três Formas</h3>
            <!-- O slide do simulador 'tres-formas-canvas' já existente serve como visualização e exploração -->
            <div class="canvas-container">
              <canvas
                id="tres-formas-canvas"
                width="800"
                height="400"
                aria-label="Simulador interativo das três formas da reta"
                role="img"
              ></canvas>
              <div class="simulator-controls">
                <div class="control-panel">
                  <label
                    for="tres-formas-a-x"
                    aria-label="Coordenada x do ponto A"
                    >A (x):</label
                  ><input
                    type="range"
                    id="tres-formas-a-x"
                    min="-10"
                    max="10"
                    value="-5"
                    step="0.5"
                  /><span id="tres-formas-a-x-value">-5.0</span
                  ><label
                    for="tres-formas-a-y"
                    aria-label="Coordenada y do ponto A"
                    >A (y):</label
                  ><input
                    type="range"
                    id="tres-formas-a-y"
                    min="-10"
                    max="10"
                    value="2"
                    step="0.5"
                  /><span id="tres-formas-a-y-value">2.0</span>
                </div>
                <div class="control-panel">
                  <label
                    for="tres-formas-b-x"
                    aria-label="Coordenada x do ponto B"
                    >B (x):</label
                  ><input
                    type="range"
                    id="tres-formas-b-x"
                    min="-10"
                    max="10"
                    value="5"
                    step="0.5"
                  /><span id="tres-formas-b-x-value">5.0</span
                  ><label
                    for="tres-formas-b-y"
                    aria-label="Coordenada y do ponto B"
                    >B (y):</label
                  ><input
                    type="range"
                    id="tres-formas-b-y"
                    min="-10"
                    max="10"
                    value="-3"
                    step="0.5"
                  /><span id="tres-formas-b-y-value">-3.0</span>
                </div>
              </div>
              <div class="hint-message">
                <p>
                  Arraste A e B. Observe como as três equações se atualizam
                  simultaneamente.
                </p>
              </div>
            </div>
          </section>

          <!-- 1.7 Conclusão -->
          <section class="debriefing">
            <h3>Conclusão: Equações da Reta</h3>
            <div class="summary-box">
              <p>
                Dominar as diferentes formas da equação da reta permite escolher
                a representação mais eficiente para cada tarefa:
              </p>
              <ul>
                <li>
                  <strong>Reduzida:</strong> Para entendimento visual rápido de
                  inclinação e intercepto.
                </li>
                <li>
                  <strong>Geral:</strong> Para cálculos robustos, distâncias e
                  compatibilidade universal (incluindo retas verticais).
                </li>
                <li>
                  <strong>Paramétrica:</strong> Para descrever movimento,
                  trajetórias e usar o poder dos vetores.
                </li>
              </ul>
            </div>
            <div class="instructor-note">
              <p>
                A flexibilidade de converter entre essas formas é uma habilidade
                tática crucial no mapeamento e navegação.
              </p>
            </div>
          </section>
        </section>

      </div>
    </div>
    <script src="https://unpkg.com/reveal.js/dist/reveal.js"></script>
    <script src="https://unpkg.com/reveal.js/plugin/notes/notes.js"></script>
    <script src="https://unpkg.com/reveal.js/plugin/highlight/highlight.js"></script>
    <script>
      window.MathJax = { tex: { inlineMath: [['\(', '\)']], displayMath: [['\[', '\]']] }, svg: { fontCache: 'global' } };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <script>
      // IIFE para visualização das três formas da reta
      (function () {
        let canvases = {}; // Store multiple canvas contexts if needed
        let pointA = { x: -5, y: 2 };
        let pointB = { x: 5, y: -3 };
        let isDragging = null;
        let activeCanvasId = null;
        const axisColor = "#ADFF2F",
          gridColor = "rgba(173, 255, 47, 0.2)",
          pointColor = "#FF6347",
          lineColor = "#FFD700",
          textColor = "#E0E0E0",
          highlightColor = "#ADFF2F";
        const baseId = "tres-formas-canvas";

        function mathToCanvas(ctxInfo, x, y) {
          return {
            x: ctxInfo.centerX + x * ctxInfo.gridSize,
            y: ctxInfo.centerY - y * ctxInfo.gridSize,
          };
        }
        function canvasToMath(ctxInfo, x, y) {
          return {
            x: (x - ctxInfo.centerX) / ctxInfo.gridSize,
            y: (ctxInfo.centerY - y) / ctxInfo.gridSize,
          };
        }
        function calcularCoeficienteAngular() {
          if (Math.abs(pointB.x - pointA.x) < 1e-9) return Infinity;
          return (pointB.y - pointA.y) / (pointB.x - pointA.x);
        }
        function calcularCoeficienteLinear(m) {
          if (m === Infinity) return null;
          return pointA.y - m * pointA.x;
        }
        function gcd(a, b) {
          a = Math.abs(Math.round(a));
          b = Math.abs(Math.round(b));
          if (b === 0) return a;
          return gcd(b, a % b);
        }
        function calcularFormaGeral() {
          let A = pointB.y - pointA.y,
            B = pointA.x - pointB.x,
            C = pointB.x * pointA.y - pointA.x * pointB.y;
          const scale = 100;
          let commonDivisor = gcd(A * scale, gcd(B * scale, C * scale)) / scale;
          if (Math.abs(commonDivisor) < 1e-6 || !isFinite(commonDivisor))
            commonDivisor = 1;
          A /= commonDivisor;
          B /= commonDivisor;
          C /= commonDivisor;
          A = parseFloat(A.toFixed(5));
          B = parseFloat(B.toFixed(5));
          C = parseFloat(C.toFixed(5));
          if (Math.abs(A) < 1e-6 && Math.abs(B) > 1e-6 && B < 0) {
            A *= -1;
            B *= -1;
            C *= -1;
          } else if (Math.abs(A) > 1e-6 && A < 0) {
            A *= -1;
            B *= -1;
            C *= -1;
          } else if (
            Math.abs(A) < 1e-6 &&
            Math.abs(B) < 1e-6 &&
            Math.abs(C) > 1e-6 &&
            C < 0
          ) {
            C *= -1;
          }
          if (Math.abs(A) < 1e-6 && Math.abs(B) < 1e-6)
            return { A: 0, B: 0, C: Math.abs(C) > 1e-6 ? 1 : 0 };
          return { A: A, B: B, C: C };
        }
        function calcularFormaParametrica() {
          const vx = pointB.x - pointA.x;
          const vy = pointB.y - pointA.y;
          return { x0: pointA.x, y0: pointA.y, vx: vx, vy: vy };
        }

        function drawGrid(ctxInfo) {
          const { ctx, width, height, centerX, centerY, gridSize } = ctxInfo;
          ctx.clearRect(0, 0, width, height);
          const gradient = ctx.createRadialGradient(
            centerX,
            centerY,
            50,
            centerX,
            centerY,
            Math.max(width, height) / 1.5,
          );
          gradient.addColorStop(0, "rgba(0, 0, 0, 0)");
          gradient.addColorStop(1, "rgba(0, 0, 0, 0.5)");
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, width, height);
          ctx.strokeStyle = gridColor;
          ctx.lineWidth = 1;
          for (let x = centerX % gridSize; x < width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
          }
          for (let y = centerY % gridSize; y < height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
          }
          ctx.strokeStyle = axisColor;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, centerY);
          ctx.lineTo(width, centerY);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(centerX, 0);
          ctx.lineTo(centerX, height);
          ctx.stroke();
          ctx.fillStyle = axisColor;
          ctx.font = '12px "Courier New", monospace';
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          for (
            let x = -Math.floor(centerX / gridSize);
            x <= Math.floor((width - centerX) / gridSize);
            x += 2
          ) {
            if (x === 0) continue;
            const canvasX = centerX + x * gridSize;
            ctx.beginPath();
            ctx.moveTo(canvasX, centerY - 5);
            ctx.lineTo(canvasX, centerY + 5);
            ctx.stroke();
            ctx.fillText(x.toString(), canvasX, centerY + 15);
          }
          for (
            let y = -Math.floor(centerY / gridSize);
            y <= Math.floor((height - centerY) / gridSize);
            y += 2
          ) {
            if (y === 0) continue;
            const canvasY = centerY - y * gridSize;
            ctx.beginPath();
            ctx.moveTo(centerX - 5, canvasY);
            ctx.lineTo(centerX + 5, canvasY);
            ctx.stroke();
            ctx.fillText(y.toString(), centerX - 15, canvasY);
          }
          ctx.fillText("0", centerX - 15, centerY + 15);
          ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
          for (let y = 0; y < height; y += 4) {
            ctx.fillRect(0, y, width, 2);
          }
        }
        function drawLine(ctxInfo) {
          const { ctx, width, height, centerX, centerY, gridSize } = ctxInfo;
          const canvasA = mathToCanvas(ctxInfo, pointA.x, pointA.y);
          const canvasB = mathToCanvas(ctxInfo, pointB.x, pointB.y);
          const m = calcularCoeficienteAngular();
          let startX, startY, endX, endY;
          const minX_math = -width / (2 * gridSize);
          const maxX_math = width / (2 * gridSize);
          const minY_math = -height / (2 * gridSize);
          const maxY_math = height / (2 * gridSize);
          if (m === Infinity || m === -Infinity) {
            startX = canvasA.x;
            startY = 0;
            endX = canvasA.x;
            endY = height;
          } else {
            const b = pointA.y - m * pointA.x;
            const xAtMinY = Math.abs(m) < 1e-9 ? Infinity : (minY_math - b) / m;
            const xAtMaxY = Math.abs(m) < 1e-9 ? Infinity : (maxY_math - b) / m;
            const yAtMinX = m * minX_math + b;
            const yAtMaxX = m * maxX_math + b;
            const points = [];
            if (yAtMinX >= minY_math && yAtMinX <= maxY_math)
              points.push(mathToCanvas(ctxInfo, minX_math, yAtMinX));
            if (yAtMaxX >= minY_math && yAtMaxX <= maxY_math)
              points.push(mathToCanvas(ctxInfo, maxX_math, yAtMaxX));
            if (xAtMinY >= minX_math && xAtMinY <= maxX_math)
              points.push(mathToCanvas(ctxInfo, xAtMinY, minY_math));
            if (xAtMaxY >= minX_math && xAtMaxY <= maxX_math)
              points.push(mathToCanvas(ctxInfo, xAtMaxY, maxY_math));
            const uniquePoints = points.filter(
              (p, index, self) =>
                index ===
                self.findIndex(
                  (t) => Math.abs(t.x - p.x) < 0.1 && Math.abs(t.y - p.y) < 0.1,
                ),
            );
            if (uniquePoints.length >= 2) {
              uniquePoints.sort((p1, p2) => p1.x - p2.x);
              startX = uniquePoints[0].x;
              startY = uniquePoints[0].y;
              endX = uniquePoints[uniquePoints.length - 1].x;
              endY = uniquePoints[uniquePoints.length - 1].y;
            } else {
              startX = canvasA.x;
              startY = canvasA.y;
              endX = canvasB.x;
              endY = canvasB.y;
            }
          }
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.strokeStyle = lineColor;
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.strokeStyle = "rgba(255, 215, 0, 0.3)";
          ctx.lineWidth = 6;
          ctx.stroke();
        }
        function drawPoints(ctxInfo) {
          const { ctx } = ctxInfo;
          const canvasA = mathToCanvas(ctxInfo, pointA.x, pointA.y);
          const canvasB = mathToCanvas(ctxInfo, pointB.x, pointB.y);
          ctx.beginPath();
          ctx.arc(canvasA.x, canvasA.y, 8, 0, 2 * Math.PI);
          ctx.fillStyle = "rgba(255, 99, 71, 0.3)";
          ctx.fill();
          ctx.beginPath();
          ctx.arc(canvasA.x, canvasA.y, 5, 0, 2 * Math.PI);
          ctx.fillStyle = pointColor;
          ctx.fill();
          ctx.strokeStyle = "#FFF";
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(canvasB.x, canvasB.y, 8, 0, 2 * Math.PI);
          ctx.fillStyle = "rgba(255, 99, 71, 0.3)";
          ctx.fill();
          ctx.beginPath();
          ctx.arc(canvasB.x, canvasB.y, 5, 0, 2 * Math.PI);
          ctx.fillStyle = pointColor;
          ctx.fill();
          ctx.strokeStyle = "#FFF";
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.fillStyle = "#FFF";
          ctx.font = '14px "Courier New", monospace';
          ctx.textAlign = "left";
          ctx.fillText(
            `A(${pointA.x.toFixed(1)}, ${pointA.y.toFixed(1)})`,
            canvasA.x + 10,
            canvasA.y - 10,
          );
          ctx.fillText(
            `B(${pointB.x.toFixed(1)}, ${pointB.y.toFixed(1)})`,
            canvasB.x + 10,
            canvasB.y - 10,
          );
        }
        function formatCoef(
          n,
          showSign = false,
          isFirst = false,
          isParam = false,
        ) {
          if (Math.abs(n) < 1e-6) return "";
          let sign = n < 0 ? "-" : showSign ? "+" : "";
          let val = Math.abs(n);
          let numStr = val.toFixed(2).replace(/\.?0+$/, "");
          if (numStr.endsWith(".")) numStr = numStr.slice(0, -1);
          let omitOne = !isFirst && !isParam;
          if (Math.abs(val - 1) < 1e-6) {
            numStr = omitOne ? "" : "1";
          }
          if (isFirst && !showSign) {
            if (Math.abs(val - 1) < 1e-6) numStr = "";
            else if (n < 0 && Math.abs(val - 1) < 1e-6) {
              sign = "-";
              numStr = "";
            } else if (n < 0) sign = "-";
            else sign = "";
          }
          if (sign === "+" && numStr.startsWith("-")) {
            sign = "";
          } else if (sign === "+" && n < 0) {
            sign = "-";
            numStr = Math.abs(n)
              .toFixed(2)
              .replace(/\.?0+$/, "");
            if (numStr.endsWith(".")) numStr = numStr.slice(0, -1);
            if (Math.abs(Math.abs(n) - 1) < 1e-6 && omitOne) numStr = "";
          }
          return `${sign} ${numStr}`;
        }
        function drawEquations(ctxInfo) {
          const { ctx } = ctxInfo;
          const m = calcularCoeficienteAngular();
          const b = calcularCoeficienteLinear(m);
          const formaGeral = calcularFormaGeral();
          const formaParametrica = calcularFormaParametrica();
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          ctx.fillRect(10, 10, 380, 100);
          ctx.strokeStyle = highlightColor;
          ctx.lineWidth = 1;
          ctx.strokeRect(10, 10, 380, 100);
          ctx.fillStyle = textColor;
          ctx.font = '14px "Courier New", monospace';
          ctx.textAlign = "left";
          ctx.textBaseline = "top";
          let equacaoFuncao;
          if (m === Infinity) {
            equacaoFuncao = `x = ${pointA.x.toFixed(1)}`;
          } else {
            let mStr = formatCoef(m, false, true);
            let bStr = formatCoef(b, true, false);
            if (Math.abs(m) < 1e-6) {
              equacaoFuncao = `y = ${b.toFixed(1)}`;
            } else {
              let xTerm = `${mStr === "1" ? "" : mStr === "-1" ? "-" : mStr}x`;
              if (mStr === "") xTerm = "x";
              equacaoFuncao = `y = ${xTerm} ${bStr}`;
              if (Math.abs(b) < 1e-6) equacaoFuncao = `y = ${xTerm}`;
            }
          }
          ctx.fillText(`Reduzida: ${equacaoFuncao}`, 20, 20);
          let equacaoGeral = "";
          let firstTerm = true;
          if (Math.abs(formaGeral.A) > 1e-6) {
            equacaoGeral += `${formatCoef(formaGeral.A, false, true)}x`;
            firstTerm = false;
          }
          if (Math.abs(formaGeral.B) > 1e-6) {
            equacaoGeral += ` ${formatCoef(formaGeral.B, !firstTerm, firstTerm)}y`;
            firstTerm = false;
          }
          if (Math.abs(formaGeral.C) > 1e-6) {
            equacaoGeral += ` ${formatCoef(formaGeral.C, !firstTerm, firstTerm)}`;
            firstTerm = false;
          }
          if (firstTerm && Math.abs(formaGeral.C) < 1e-6)
            equacaoGeral = "0 = 0";
          else if (firstTerm)
            equacaoGeral = `${formatCoef(formaGeral.C, false, true)} = 0`;
          else equacaoGeral += " = 0";
          equacaoGeral = equacaoGeral
            .replace(/\s+/g, " ")
            .replace(" + -", " - ")
            .replace(" - -", " + ")
            .trim();
          if (equacaoGeral.startsWith("+ "))
            equacaoGeral = equacaoGeral.substring(2);
          ctx.fillText(`Geral: ${equacaoGeral}`, 20, 50);
          let vxStr = formatCoef(formaParametrica.vx, true, false, true);
          let vyStr = formatCoef(formaParametrica.vy, true, false, true);
          let xParam = `x = ${formaParametrica.x0.toFixed(1)}${vxStr}t`;
          let yParam = `y = ${formaParametrica.y0.toFixed(1)}${vyStr}t`;
          xParam = xParam
            .replace(/ \+ 1t/g, "+t")
            .replace(/ - 1t/g, "-t")
            .replace(/ 1t/g, "t")
            .replace(/\s\+\s/g, "+")
            .replace(/\s-\s/g, "-");
          yParam = yParam
            .replace(/ \+ 1t/g, "+t")
            .replace(/ - 1t/g, "-t")
            .replace(/ 1t/g, "t")
            .replace(/\s\+\s/g, "+")
            .replace(/\s-\s/g, "-");
          ctx.fillText(`Paramétrica: ${xParam}, ${yParam}`, 20, 80);
        }
        function draw(canvasId) {
          if (!canvases[canvasId]) return;
          drawGrid(canvases[canvasId]);
          drawLine(canvases[canvasId]);
          drawPoints(canvases[canvasId]);
          drawEquations(canvases[canvasId]);
        }
        function updateUI(instanceSuffix = "") {
          const aXIn = document.getElementById(
              `tres-formas-a-x${instanceSuffix}`,
            ),
            aYIn = document.getElementById(`tres-formas-a-y${instanceSuffix}`),
            bXIn = document.getElementById(`tres-formas-b-x${instanceSuffix}`),
            bYIn = document.getElementById(`tres-formas-b-y${instanceSuffix}`);
          const aXV = document.getElementById(
              `tres-formas-a-x-value${instanceSuffix}`,
            ),
            aYV = document.getElementById(
              `tres-formas-a-y-value${instanceSuffix}`,
            ),
            bXV = document.getElementById(
              `tres-formas-b-x-value${instanceSuffix}`,
            ),
            bYV = document.getElementById(
              `tres-formas-b-y-value${instanceSuffix}`,
            );
          if (aXIn && aYIn && bXIn && bYIn && aXV && aYV && bXV && bYV) {
            aXIn.value = pointA.x;
            aYIn.value = pointA.y;
            bXIn.value = pointB.x;
            bYIn.value = pointB.y;
            aXV.textContent = pointA.x.toFixed(1);
            aYV.textContent = pointA.y.toFixed(1);
            bXV.textContent = pointB.x.toFixed(1);
            bYV.textContent = pointB.y.toFixed(1);
          }
        }
        function handleMouseDown(e) {
          activeCanvasId = e.target.id;
          if (!canvases[activeCanvasId]) return;
          const rect = e.target.getBoundingClientRect();
          const mX = e.clientX - rect.left,
            mY = e.clientY - rect.top;
          const cA = mathToCanvas(canvases[activeCanvasId], pointA.x, pointA.y),
            cB = mathToCanvas(canvases[activeCanvasId], pointB.x, pointB.y);
          const dxA = cA.x - mX,
            dyA = cA.y - mY,
            distA = Math.sqrt(dxA * dxA + dyA * dyA);
          const dxB = cB.x - mX,
            dyB = cB.y - mY,
            distB = Math.sqrt(dxB * dxB + dyB * dyB);
          if (distA < 15) {
            isDragging = "A";
          } else if (distB < 15) {
            isDragging = "B";
          } else {
            isDragging = null;
          }
        }
        function handleMouseMove(e) {
          if (!isDragging || !activeCanvasId || !canvases[activeCanvasId])
            return;
          const rect = canvases[activeCanvasId].canvas.getBoundingClientRect();
          const mX = e.clientX - rect.left,
            mY = e.clientY - rect.top;
          const mathC = canvasToMath(canvases[activeCanvasId], mX, mY);
          const nX = Math.max(-10, Math.min(10, Math.round(mathC.x * 2) / 2));
          const nY = Math.max(-10, Math.min(10, Math.round(mathC.y * 2) / 2));
          if (isDragging === "A") {
            if (
              Math.abs(nX - pointB.x) > 1e-6 ||
              Math.abs(nY - pointB.y) > 1e-6
            ) {
              pointA.x = nX;
              pointA.y = nY;
            }
          } else if (isDragging === "B") {
            if (
              Math.abs(nX - pointA.x) > 1e-6 ||
              Math.abs(nY - pointA.y) > 1e-6
            ) {
              pointB.x = nX;
              pointB.y = nY;
            }
          }
          updateUI();
          updateUI("-2");
          draw(baseId);
          draw(baseId + "-2");
        }
        function handleMouseUp() {
          isDragging = null;
          activeCanvasId = null;
        }
        function handleTouchStart(e) {
          if (e.touches.length === 1) {
            e.preventDefault();
            const t = e.touches[0];
            e.target.dispatchEvent(
              new MouseEvent("mousedown", {
                clientX: t.clientX,
                clientY: t.clientY,
                bubbles: true,
              }),
            );
          }
        } // Target the specific canvas
        function handleTouchMove(e) {
          if (e.touches.length === 1) {
            e.preventDefault();
            const t = e.touches[0];
            document.dispatchEvent(
              new MouseEvent("mousemove", {
                clientX: t.clientX,
                clientY: t.clientY,
              }),
            );
          }
        }
        function handleTouchEnd(e) {
          document.dispatchEvent(new MouseEvent("mouseup", {}));
        }
        function handleControlChange(event) {
          const instanceSuffix = event.target.id.includes("-2") ? "-2" : "";
          const otherSuffix = instanceSuffix === "-2" ? "" : "-2";
          const aXIn = document.getElementById(
              `tres-formas-a-x${instanceSuffix}`,
            ),
            aYIn = document.getElementById(`tres-formas-a-y${instanceSuffix}`),
            bXIn = document.getElementById(`tres-formas-b-x${instanceSuffix}`),
            bYIn = document.getElementById(`tres-formas-b-y${instanceSuffix}`);
          if (aXIn && aYIn && bXIn && bYIn) {
            const nAx = parseFloat(aXIn.value),
              nAy = parseFloat(aYIn.value),
              nBx = parseFloat(bXIn.value),
              nBy = parseFloat(bYIn.value);
            if (Math.abs(nAx - nBx) > 1e-6 || Math.abs(nAy - nBy) > 1e-6) {
              pointA.x = nAx;
              pointA.y = nAy;
              pointB.x = nBx;
              pointB.y = nBy;
            } else {
              updateUI(instanceSuffix);
              return;
            }
            draw(baseId);
            draw(baseId + "-2");
            updateUI(instanceSuffix);
            updateUI(otherSuffix);
          }
        }
        function init(forceRedraw = false) {
          const idsToInit = [baseId, baseId + "-2"];
          let primaryInitialized = false;
          idsToInit.forEach((canvasId) => {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return; // Skip if canvas not found
            if (!canvases[canvasId] || forceRedraw) {
              // Initialize or re-initialize if forced
              if (
                canvas.getAttribute("data-initialized") !== "true" ||
                forceRedraw
              ) {
                const ctx = canvas.getContext("2d");
                const width = canvas.width;
                const height = canvas.height;
                const centerX = Math.floor(width / 2);
                const centerY = Math.floor(height / 2);
                const gridSize = 30;
                canvases[canvasId] = {
                  canvas,
                  ctx,
                  width,
                  height,
                  centerX,
                  centerY,
                  gridSize,
                };

                if (canvas.getAttribute("data-listeners-set") !== "true") {
                  // Add listeners only once
                  canvas.addEventListener("mousedown", handleMouseDown);
                  canvas.addEventListener("touchstart", handleTouchStart, {
                    passive: false,
                  });
                  canvas.setAttribute("data-listeners-set", "true");
                }
                canvas.setAttribute("data-initialized", "true");
                if (canvasId === baseId) primaryInitialized = true; // Track if the main one initialized
              }
            }
          });
          // Add global mouse/touch move/end listeners only once
          if (!document.body.hasAttribute("data-global-tresformas-listeners")) {
            document.addEventListener("mousemove", handleMouseMove);
            document.addEventListener("mouseup", handleMouseUp);
            document.addEventListener("touchmove", handleTouchMove, {
              passive: false,
            });
            document.addEventListener("touchend", handleTouchEnd);
            document.body.setAttribute(
              "data-global-tresformas-listeners",
              "true",
            );
          }
          // Add input listeners only once
          const ids = ["a-x", "a-y", "b-x", "b-y"];
          ids.forEach((id) => {
            const input1 = document.getElementById(`tres-formas-${id}`);
            const input2 = document.getElementById(`tres-formas-${id}-2`);
            if (input1 && !input1.hasAttribute("data-listener-set")) {
              input1.addEventListener("input", handleControlChange);
              input1.setAttribute("data-listener-set", "true");
            }
            if (input2 && !input2.hasAttribute("data-listener-set")) {
              input2.addEventListener("input", handleControlChange);
              input2.setAttribute("data-listener-set", "true");
            }
          });

          if (primaryInitialized || forceRedraw) {
            // Perform initial draw/update if main canvas was inited or forced
            draw(baseId);
            draw(baseId + "-2");
            updateUI();
            updateUI("-2");
          }
        }
        if (
          document.readyState === "complete" ||
          document.readyState === "interactive"
        ) {
          setTimeout(init, 50);
        } else {
          document.addEventListener("DOMContentLoaded", init);
        }
        if (typeof Reveal !== "undefined") {
          Reveal.addEventListener("slidechanged", (event) => {
            const currentCanvas = event.currentSlide.querySelector(
              `canvas[id^="${baseId}"]`,
            );
            if (currentCanvas) {
              init(true);
            }
          });
          Reveal.on("ready", (event) => {
            init();
          });
        } else {
          init();
        }
        window.tresFormasVisualization = { init: () => init(true) }; // Expose for re-init
      })();
    </script>
    <script>
      Reveal.initialize({ hash: true, slideNumber: true, plugins: [RevealNotes, RevealHighlight] });
    </script>
  </body>
</html>
